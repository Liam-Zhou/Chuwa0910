# hw11- Ke Chen

## 1.  List all of the annotations you learned from class and homework to annotaitons.md
see files annotations.md

## 2.  What is Spring and Springboot? What is the benfits of using Srpingboot?
### Spring
Spring is a <u>lightweight, loosely coupled and integrated framework</u> for <u>developing</u> enterprise <u>applications</u> in java.

### Springboot
Spring Boot is a Spring <u>module</u> which <u>provides RAD (Rapid Application Development) feature to Spring framework</u>.

It is used to <u>create stand alone spring application</u> that you can just run because it needs very little spring configuration.
Spring Boot是一个Spring模块，为Spring框架提供RAD（快速应用程序开发）功能。
它用于创建独立的基于 spring 的应用程序，您可以运行该应用程序，因为它需要很少的 spring 配置。

### the benfits of using Srpingboot?
- Create stand-alone Spring applications that can be started using java -jar.
- Embed Tomcat, Jetty or Undertow directly. You don't need to deploy WAR files.
- It provides opinionated 'starter' POMs to simplify your Maven configuration.
- It automatically configure Spring whenever possible.

- 创建可以使用java -jar 启动的独立Spring 应用程序。
- 直接嵌入Tomcat、Jetty或Undertow。 您不需要部署 WAR 文件。
- 它提供固执己见的“入门”POM 来简化您的 Maven 配置。
- 它会尽可能自动配置Spring。

## 3.  What is IOC and What is DI?
IOC is stand for Inversion of Control and DI is stand for Dependency Injection

IOC container is responsible to:
- create the instance
- configure the instance
- assemble the dependencies

The Container uses Dependency Injection(DI) to manage the components that make up the application. 

## 4.  What is  @CompnonentScan?
@ComponentScan is an annotation in Spring Framework that is used to <u>specify the base packages to scan for Spring-managed components</u>.
扫描特定文件的bean class

## 5.  How to define which package spring need to scan in xml and annotaiton? 
### By use @ComponentScan
By use @ComponentScan in Java configuration class (usually annotated with @Configuration) to define the base packages to scan. It's typically placed at the top of configuration class. Here's how you can use @ComponentScan:
```java
@Configuration
@ComponentScan(basePackages = "com.example.myapp")
public class AppConfig {
    // Define other beans and configuration here
}
```
In the above example, @ComponentScan instructs Spring to scan the com.example.myapp package and its sub-packages for classes annotated with Spring component annotations (@Component, @Service, etc.). Spring will then automatically register these classes as beans in the application context.

### By using XML configuration
By using XML configuration, we can use the <context:component-scan> element within XML configuration file (applicationContext.xml). Here's the example:
```java
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="com.example.myapp" />
    
    <!-- Define other beans and configuration here -->

</beans>
```
In this XML configuration, <context:component-scan> is used to specify the base package(s) that Spring should scan for components. It's equivalent to using @ComponentScan in a Java configuration class. We can specify multiple base packages by providing a comma-separated list or using multiple <context:component-scan> elements.

## 6.  What is  @SpringbootApplication?
@SpringBootApplication is a meta-annotation in Spring Boot that combines three commonly used annotations: @Configuration, @EnableAutoConfiguration, and @ComponentScan. It's a convenient way to enable various features for a Spring Boot application and is often used to mark the main class of the Spring Boot application. （项目开始的地方）

Here's an example of how to use @SpringBootApplication:
```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MySpringBootApplication {

    public static void main(String[] args) {
        SpringApplication.run(MySpringBootApplication.class, args);
    }
}
```
In this example, MySpringBootApplication is marked with @SpringBootApplication, and <u>it serves as the entry point of the Spring Boot application</u>. When run the application, Spring Boot takes care of configuring the application context, scanning for components, and setting up various features, making it easier to get started with Spring Boot development.

## 7. How many ways wo can define a bean?
- class level:
    - @Component
    - @Service
    - @Repository
    - @Controller
    - @ControllerAdvice
- Method level
    - @Bean(used with @Configuration) together
- XML
    - by tag <bean></bean>

## 8.  What is default bean name for  @Component and  @Bean?
### For @Component
the default bean name for a class annotated with @Component is generated <u>based on the class name, but with the first letter in lowercase</u>

For example, if you have a class named MyComponent, the default bean name would be myComponent.
```java
@Component
public class MyComponent {
    // ...
}
```
In this case, Spring will automatically register the MyComponent class as a bean with the name myComponent.


### For @Bean
the default bean name <u>is based on the method name</u> used to define the bean. 

For example, if you have a method named myBean that is annotated with @Bean, the default bean name would be myBean.
```java
@Configuration
public class AppConfig {
    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
}
```
In this case, Spring will automatically register the myBean method as a bean, and the bean's name will be myBean.

## 9.  What is the difference between  @component and  @service,@repository?
1. **`@Component`**:
   - `@Component` is the most generic stereotype annotation and <u>is used to indicate that a class is a Spring component</u>来表明a class是一个spring的component. It does not provide any specific information about the role or purpose of the component. <u>It's often used for generic, non-specialized components</u>.

   ```java
   @Component
   public class MyComponent {
       // ...
   }
   ```

2. **`@Service`**:
   - `@Service` is a specialization of `@Component`. It is typically <u>used to indicate that a class is a service or business logic component</u> 核心业务逻辑. The use of `@Service` carries the intent that the class is meant for providing specific business services and is a part of the service layer in application.

   ```java
   @Service
   public class MyService {
       // ...
   }
   ```

3. **`@Repository`**:
   - `@Repository` is another specialization of `@Component`. It is specifically <u>intended for DAO (Data Access Object) classes, which are responsible for interacting with the database or other data storage mechanisms 和数据库打交道</u>. The use of `@Repository` indicates that the class's purpose is data access and persistence.

   ```java
   @Repository
   public class MyRepository {
       // ...
   }
   ```

## 10. How many annotaitons we can use to inject the bean?
In Spring Framework, there are several annotations can use to inject beans, including:

1. **@Autowired**: The `@Autowired` annotation is used to inject beans by type. We can use it on fields, constructors, or setter methods.

   ```java
   @Autowired
   private MyBean myBean;
   ```

2. **@Qualifier**: The `@Qualifier` annotation is used in conjunction with `@Autowired` to specify which bean to inject when there are multiple beans of the same type. provide the name of the bean that want to inject as an argument to `@Qualifier`.

   ```java
   @Autowired
   @Qualifier("myBean")
   private MyBean myBean;
   ```

3. **@Resource**: The `@Resource` annotation can be used for dependency injection by name. We can specify the name of the bean to inject using the `name` attribute.

   ```java
   @Resource(name = "myBean")
   private MyBean myBean;
   ```

4. **@Inject**: The `@Inject` annotation is part of the Java Dependency Injection (JSR-330) standard. It is similar to `@Autowired` and can be used for bean injection by type.

   ```java
   @Inject
   private MyBean myBean;
   ```

## 11. Tell me the three types to do dependency injection(How can we inject the beans in Spring)? Which way is better and why?

1. **Constructor Injection**: 通过构造器注入
   - Constructor injection is a method of injecting dependencies by <u>passing them as arguments to a class's constructor</u>. 
   
   This is generally considered the best and most recommended way of performing dependency injection in Spring for several reasons:
     - It ensures that a bean is fully initialized when it is created, making it clear that the bean is in a consistent state.
     - It provides immutability, as the dependencies cannot be changed after the bean is constructed.
     - It makes it easy to enforce that a bean has its required dependencies, as the constructor must receive them.

   ```java
   @Component
   public class MyService {
       private final MyDependency dependency;

       @Autowired
       public MyService(MyDependency dependency) {
           this.dependency = dependency;
       }

       // ...
   }
   ```

2. **Setter Injection**:
   - Setter injection involves injecting dependencies <U>using setter methods 用setter方法</u>. While it provides more flexibility in changing dependencies at runtime. 
   
   It is generally considered less preferred than constructor injection because it doesn't guarantee that a bean is fully initialized when created. However, setter injection can be useful for optional dependencies or when dealing with frameworks that require default constructors.

   ```java
   @Component
   public class MyService {
       private MyDependency dependency;

       @Autowired
       public void setDependency(MyDependency dependency) {
           this.dependency = dependency;
       }

       // ...
   }
   ```

3. **Field Injection**:
   - Field injection involves <u>injecting dependencies directly into fields or propertie 直接注入到fields或者properties里面</u> of a bean. 
   
   While it's concise and convenient, it is considered less preferred for injecting dependencies because it may make the code less testable and harder to maintain. Field injection should be used sparingly and only for cases where the use of setters or constructors is not feasible.

   ```java
   @Component
   public class MyService {
       @Autowired
       private MyDependency dependency;

       // ...
   }
   ```

## 12. If we have multiple beans for one type, how to set one is primary? and how to let the spring to pick one bean to inject if no primay.
We can use the `@Primary` annotation. The `@Primary` annotation tells Spring to use a particular bean as the primary choice when there are multiple candidates of the same type. If a primary bean is available, Spring will inject that one by default.

Here's how to use `@Primary`:

```java
@Component
@Primary
public class PrimaryBean implements MyBean {
    // ...
}
```
In this example, `PrimaryBean` is marked as the primary bean of type `MyBean`. If there are other beans of type `MyBean` in the context, Spring will use `PrimaryBean` by default.

## 13. What is the difference between BeanFactory and ApplicationContext in Spring?
- 1.BeanFactory is the basic container whereas ApplicationContext is the advanced container. 
ApplicationContext extends the BeanFactory interface. 
- 2.ApplicationContext provides more facilities than BeanFactory such as integration(集成) with spring AOP, message resource handling for i18n etc.


- 1.BeanFactory是Spring的早期接口，称为Spring的Bean工厂，ApplicationContext是后期更高级接口，称之为Spring 容器。
- 2.ApplicationContext在BeanFactory基础上对功能进行了扩展，例如：监听功能、国际化功能等。BeanFactory的API更偏向底层，ApplicationContext的API大多数是对这些底层API的封装。
- 3.Bean创建的主要逻辑和功能都被封装在BeanFactory中，ApplicationContext不仅继承了BeanFactory，而且ApplicationContext 内部维护了 BeanFactory： 既有继承关系，也有内部融合关系.
- 4.Bean的初始化时机不同，原始BeanFactory是在首次调用getBean时才进行Bean的创建，而ApplicationContext则是配置文件加载，容器一创建就将Bean都实例化并初始化好。

## 14. What is the Scope of a Bean?  and list the examples for each scope.

- `singleton`: the bean instance will created be only once and same instance will be returned by the IOC container
- `prototype`: the bean instance will be created each time when requested.
- `request`: the bean instance will be created per HTTP request
- `session`: the bean instance will be created per HTTP session
- `globalsession`:  the bean instance will be created per HTTP global session. It can be used in portlet context only.

## 15. Configure a bean using xml. If bean has parameters/dependencies, how can we configure the bean? (you can google the tutorial how to configure beans in xml, and feel free to ask me any quesitons if you don't understand. it is a little bit old, I am not sure if I need to exaplain it in class)
In Spring XML configuration, we can define beans and configure them, including specifying their dependencies, by using the `<bean>` element and related attributes. To configure a bean with parameters or dependencies, we can use the following approach:

1. **Define the Bean in XML**: First, define the bean using the `<bean>` element. We need to specify the following attributes:
   - `id` or `name`: The unique identifier for the bean.
   - `class`: The fully-qualified class name of the bean.
   
   For example:

   ```xml
   <bean id="myBean" class="com.example.MyBean">
       <!-- Bean configuration goes here -->
   </bean>
   ```

2. **Configure Dependencies**: To configure dependencies or set properties for the bean, we can use child elements within the `<bean>` element. There are various elements can use for different types of dependencies or properties:
   - `<property>`: Used to set properties on the bean. It's particularly useful for setting simple values.
   - `<ref>`: Used to reference other beans and inject them as dependencies.
   - `<list>`, `<set>`, `<map>`, and `<props>`: Used for configuring collections and maps.
   
   Here's an example of configuring a dependency using `<property>`:

   ```xml
   <bean id="myBean" class="com.example.MyBean">
       <property name="myProperty" value="someValue" />
   </bean>
   ```

   We can use `<ref>` to inject other beans as dependencies:

   ```xml
   <bean id="myBean" class="com.example.MyBean">
       <property name="myDependency">
           <ref bean="anotherBean" />
       </property>
   </bean>
   ```

3. **Injecting Values from Properties Files**: If we want to inject values from external properties files, we can use placeholders. We typically use the `property-placeholder` element to configure the location of the properties file.

   ```xml
   <bean id="myBean" class="com.example.MyBean">
       <property name="myProperty" value="${some.property}" />
   </bean>

   <context:property-placeholder location="classpath:my-properties-file.properties" />
   ```

4. **Importing Additional XML Configuration Files**: If configuration becomes too large, we can split it into multiple XML files and import them into main configuration file using the `<import>` element.

   ```xml
   <import resource="classpath:additional-configuration.xml" />
   ```

5. **Define Additional Beans**: We can define more beans by creating additional `<bean>` elements within XML configuration file, and we can reference or inject these beans as dependencies in other beans.


