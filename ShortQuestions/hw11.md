### What is Spring and Springboot? What is the benfits of using Srpingboot?
Spring is a popular Java framework that provides a comprehensive infrastructure for building enterprise applications. 
It provides features such as dependency injection, aspect-oriented programming, and transaction management.

Spring Boot is a build tool and framework extension that makes it easy to create Spring-based applications. 
It provides auto-configuration features that simplify the setup and configuration of Spring applications.

Benefits of Spring Boot:

* Auto Configuration: It automatically configures your application based on the libraries on the classpath.
* Stand-alone: It builds production-ready applications with an embedded servlet container (like Tomcat) or as a standalone application.
* Opinionated Defaults: It provides a set of default configurations and eliminates the need for specifying beans and configurations.
* Production Ready: It includes features like health checks and metrics to monitor and manage your application in production.
* Microservices: Ideal for building microservices-based architectures due to its simplicity and ease of deployment.

### What is IOC and What is DI?

IOC (Inversion of Control): It is a design principle where the control of objects is transferred from the program itself to an external container or framework.

DI (Dependency Injection): It is a technique where one object supplies the dependencies of another object, thus decoupling the object creation from its usage.

### What is @CompnonentScan

@ComponentScan is an annotation used in Spring to specify the base packages to scan for components (like @Component, @Service, @Repository, etc.). 
It is often used in conjunction with @Configuration classes to define the components that should be managed by Spring.

### How to define which package spring need to scan in xml and annotaiton? 

In XML, you can define which package Spring needs to scan for beans using the ``` <context:component-scan> ``` element. In annotation, you can use the @ComponentScan annotation.

### What is @SpringbootApplication

The @SpringBootApplication annotation is a convenience annotation that combines several Spring Boot annotations, including @Configuration, 
@EnableAutoConfiguration, and @ComponentScan. It is typically used on the main class of a Spring Boot application.

### How many ways wo can define a bean?

There are two main ways to define a bean in Spring:

* XML configuration: You can define beans in XML configuration files.
* Java configuration: You can define beans in Java configuration classes.

### What is default bean name for @Component and @Bean ?

The default bean name for @Component and @Bean is the fully qualified class name of the bean.

### What is the difference between @Component and @service,@repository

The @Component annotation is a general-purpose annotation that can be used to mark any class as a bean. 
The @Service and @Repository annotations are specialized annotations that are used to mark service and repository beans, respectively.

### How many annotaitons we can use to inject the bean?

There are three main annotations that can be used to inject beans in Spring:

* @Autowired: Tells Spring to automatically inject a dependency into a bean.
* @Qualifier: Used to specify a specific bean to inject when there are multiple beans of the same type.
* @Resource: Similar to @Autowired, but can be used to inject beans from JNDI (Java Naming and Directory Interface).
  
### Tell me the three types to do dependency injection(How can we inject the beans in Spring)? Which way is better and why?

The three types of dependency injection in Spring are:

Constructor injection: Spring injects the dependencies into the bean's constructor.
Setter injection: Spring injects the dependencies into the bean's setter methods.
Field injection: Spring injects the dependencies into the bean's fields.
Constructor injection is generally considered to be the best way to inject dependencies in Spring. It is the most explicit and type-safe way to inject dependencies. It also ensures that the dependencies are injected before the bean is initialized, which can help to prevent errors.

Setter injection is a good alternative to constructor injection when the dependencies are not known at compile time. It is also a good option for injecting optional dependencies.

Field injection is generally not recommended in Spring. It is less explicit and type-safe than constructor or setter injection. It can also lead to errors if the dependencies are not injected before the bean is initialized.

Here is an example of how to use each type of dependency injection:

Constructor injection:

```java
public class MyBean {
    private MyDependency myDependency;

    public MyBean(MyDependency myDependency) {
        this.myDependency = myDependency;
    }

    // ...
}
```

Setter injection:

```Java
public class MyBean {
    private MyDependency myDependency;

    public void setMyDependency(MyDependency myDependency) {
        this.myDependency = myDependency;
    }

    // ...
}
```
Field injection:

```Java
public class MyBean {
    @Autowired
    private MyDependency myDependency;

    // ...
}
```
Spring will automatically inject the MyDependency bean into the MyBean bean using the type of dependency injection that is specified.


### If we have multiple beans for one type, how to set one is primary? and how to let the spring to pick one bean to inject if no primay.

To set one bean as the primary bean when there are multiple beans of the same type, you can use the @Primary annotation. The @Primary annotation tells Spring to prefer that bean when injecting dependencies.

If there is no primary bean and there are multiple beans of the same type, Spring will throw an exception.

To avoid getting an exception, you can use the @Qualifier annotation to specify the specific bean that you want to inject.

Here is an example:
```java
public interface MyDependency {
    // ...
}

@Service
public class MyDependencyImpl1 implements MyDependency {
    // ...
}

@Service
@Primary
public class MyDependencyImpl2 implements MyDependency {
    // ...
}

public class MyBean {
    @Autowired
    private MyDependency myDependency;

    // ...
}
```

In this example, Spring will inject the MyDependencyImpl2 bean into the MyBean bean because it is the primary bean.

If you want to inject the MyDependencyImpl1 bean, you can use the @Qualifier annotation:

```Java
public class MyBean {
    @Autowired
    @Qualifier("myDependencyImpl1")
    private MyDependency myDependency;

    // ...
}
```



### What is the difference between BeanFactory and ApplicationContext in Spring?

The BeanFactory interface is a basic interface for managing beans. It provides methods for creating, retrieving, and removing beans.

The ApplicationContext interface extends the BeanFactory interface and provides additional features, such as:

* Support for multiple bean scopes
* Support for resource loading
* Support for event publishing and listening
* Support for internationalization and localization
* The ApplicationContext interface is the preferred interface for managing beans in Spring applications.

### What is the Scope of a Bean?  and list the examples for each scope.

The scope of a bean determines how long the bean instance will live. There are six bean scopes in Spring:

* Singleton: The bean instance is created once and shared across the entire application.
* Prototype: A new bean instance is created each time the bean is requested.
* Request: A new bean instance is created for each HTTP request.
* Session: A new bean instance is created for each HTTP session.
* Global session: A new bean instance is created for each global HTTP session.
* WebSocket: A new bean instance is created for each WebSocket connection.

Here are some examples of when to use each bean scope:

* Singleton: Use the singleton scope for beans that are shared across the entire application, such as configuration settings and database connections.
* Prototype: Use the prototype scope for beans that are not shared across the application, such as beans that contain state information.
* Request: Use the request scope for beans that are only needed for a single HTTP request, such as beans that contain request parameters or session attributes.
* Session: Use the session scope for beans that are needed for the entire HTTP session, such as beans that contain shopping cart items or user preferences.
* Global session: Use the global session scope for beans that are needed for the entire global HTTP session, such as beans that contain authentication information.
* WebSocket: Use the WebSocket scope for beans that are needed for the entire WebSocket connection, such as beans that contain chat history or game state information.

### Configure a bean using xml. If bean has parameters/dependencies, how can we configure the bean?

XML Configuration with Constructor Injection:

```xml
<bean id="myBean" class="com.example.MyBean">
    <constructor-arg ref="dependencyBean" />
</bean>

<bean id="dependencyBean" class="com.example.DependencyBean" />
```

XML Configuration with Setter Injection:

```xml
<bean id="myBean" class="com.example.MyBean">
    <property name="dependency" ref="dependencyBean" />
</bean>

<bean id="dependencyBean" class="com.example.DependencyBean" />
```

In both cases, MyBean class has a constructor or setter method that accepts an instance of DependencyBean.
The XML configuration injects the dependencyBean into myBean using constructor or setter injection.
