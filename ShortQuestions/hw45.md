2.
Authentication is the process of verifying the identity of a user, or systemâ€¦, like verifying the username and password combo.

3.
Authorization refers to the process of determining what permissions an authenticated user or system has for a specific resource or action

4.
Authentication: To ensure that users are who they claim to be.
Authorization: To ensure that authenticated users can only access the resources and perform the operations they are permitted to.

5.
HTTP Session is a mechanism used by web applications to store user-specific data temporarily on the server between multiple requests from the same user. Since the HTTP protocol is stateless (each request from a client to a server is treated as an isolated event, unrelated to any previous or future requests), sessions provide a way to retain stateful information across multiple client interactions.

6.
A cookie is a small piece of data that a server sends to a user's web browser. The browser may store it and send it back with later requests to the same server. Typically, cookies are used to remember users and their settings, enabling web applications to recognize returning users and provide personalized experiences.

7.
The key difference between sessions and cookies is that sessions are saved on the server side while cookies are saved on the client side. Cookies are small text files used to store user information on the user's computer. Sessions are used to store user information on the user's server side

8.
Using Sessions:
Once a session is established, the server can store information in it. For example, user preferences, shopping cart data, etc., can be stored in the session.
This information remains available for the entire duration of the session. It allows for personalized user experiences, such as greeting the user by name or remembering the contents of their shopping cart between visits.
The session data is stored on the server-side, making it secure for sensitive data. But remember, the session ID itself (usually stored in a cookie) needs to be secure to prevent session hijacking.

Using Cookies:
Besides the session ID, other non-sensitive data can also be stored directly in cookies.
For example, if a user selects a theme or language preference for a website, this can be stored in a cookie. The next time the user visits, the site can read this cookie and apply the user's preferred theme or language.
Cookies can be set to expire after a specific time. For persistent login features, a long-lived cookie can be used to remember the user, and upon revisiting, the server can automatically log the user in.
For security, always use the HttpOnly attribute for cookies that store session IDs to prevent access by JavaScript (mitigating certain XSS attacks). If the application uses HTTPS (which it should for authentication), the Secure attribute should be set to ensure the cookie is only sent over secure channels.

9.
JWT stands for JSON Web Token. It's a compact, URL-safe means of representing claims to be transferred between two parties. The claims in a JWT are encoded as a JSON object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or integrity protected with a Message Authentication Code (MAC) and/or encrypted.

10.
Spring Security maintains a filter chain internally where each of the filters has a particular responsibility and filters are added or removed from the configuration depending on which services are required. The ordering of the filters is important as there are dependencies between them.

11.
The client sends authentication credentials (e.g., a username and password) to the server.
The server verifies the credentials. If they are valid, it generates a JWT containing a payload (called claims) about the user. Common claims include user ID, issued-at time, expiration time, and other relevant data.
The client stores the JWT, typically in an HTTP cookie, local storage, or session storage.
JWTs usually have a short lifespan, defined by the expiration claim.
When a request is made to a protected resource, the server can check these claims in the JWT to determine if the user has the required permissions to access the resource.

12.
Password Encoders
Password encoders are algorithms that transform a password into a fixed-size string of bytes, which is typically a digest that is unique to each unique password. Commonly used algorithms include: BCrypt, SCrypt, Argon2, PBKDF2

13.
UserDetailsService:
An interface that defines a single method: loadUserByUsername(String username).
It's used to retrieve user-related data, such as username, password, and granted authorities.
Typically, you implement this interface to provide custom logic to fetch user details from your data source (e.g., a database).

AuthenticationProvider:
An interface responsible for the actual authentication logic.
It has a method authenticate(Authentication authentication) that processes a specific Authentication object type and returns a fully populated Authentication object on successful authentication.
The most common implementation provided by Spring Security is DaoAuthenticationProvider, which works in conjunction with UserDetailsService to authenticate a user using a data source.

AuthenticationManager:
An interface with a single method: authenticate(Authentication authentication).
It's the main entry point for performing authentication in Spring Security.
ProviderManager is a common implementation that delegates to a chain of AuthenticationProvider implementations.

AuthenticationFilter:
It's a concept rather than a specific class. Spring Security provides a range of filters that implement specific authentication mechanisms, and these filters extract authentication details from the incoming request, attempt authentication, and handle both successful and unsuccessful authentication scenarios.
For example, UsernamePasswordAuthenticationFilter processes form-based authentication. It extracts the username and password from a request, packages them into an Authentication object, and passes it to the AuthenticationManager.
Another example is JwtAuthenticationFilter (often custom-implemented in JWT setups), which extracts a JWT token from the request header, verifies it, and sets the authentication context accordingly.

14.
Server-side sessions store session data on the server, so as the number of active users grows, memory consumption on the server increases. This becomes a problem when you scale the application horizontally (i.e., adding more servers), as each server will maintain its session data.

Overcome by using Stateless Authentication (e.g., JWT):
Instead of using server-side sessions, tokens like JWT (JSON Web Tokens) can be used. Once authenticated, the server generates a token and sends it to the client. The client sends this token with every subsequent request. Since the server doesn't need to maintain any session data, this approach is inherently stateless and scales better.

15.
In Spring Boot, you can retrieve values from application.properties using the @Value annotation or by binding properties directly to POJOs using @ConfigurationProperties. 

16.
configure(HttpSecurity http)
This method configures web-based security for specific HTTP requests. By overriding it, you can specify security directives for specific URL patterns, set up login and logout behavior, configure CSRF protection, and more.


configure(AuthenticationManagerBuilder auth)
This method configures user authentication. By overriding it, you set up the way Spring Security should fetch user credentials, match passwords, assign roles, etc.

17.
Authentication is the process of establishing a known identity for the user, i.e., determining who the user is. It's about answering the question: "Who are you?"

Once we have verified who the user is (through authentication), we then need to determine what they are allowed to do. This is where authorization comes into play. It's about answering the question: "Are you allowed to do what you're trying to do?"
