# HW41 - Grace Hu

#### 1. annotations.md
    
#### 2. Type the Comment feature for the class project./3. In postman, call of the APIs in PostController and CommentController.
see code

#### 4. what is JPA? and what is Hibernate?
**JPA** is a standard of Object Relational Mapping. It is an interface that defines a set of annotations for creating the object relational mapping. It uses JDBC to CRUD database, and also transfer result from database to Java Entities.

**Hibernate** is the most popular ORM framework.

#### 5. What is Hikari? what is the benefits of connection pool?

**Hikari** is a JDBC connection pool.

The **connection pool** efficiently manages and reuses database connections, reducing the overhead of opening and closing connections for each database operation(like thread pool).

    
#### 6. What is the @OneToMany, @ManyToOne, @ManyToMany? write some examples.

**@OneToMany**: applies to a collection-type field in the parent entity, representing a set of related child entities.

    public class Post {
        ...
        
        @OneToMany(mappedBy = "post", cascade = CascadeType.ALL)
        private Set<Comment> comments = new HashSet<>();
    }


**@ManyToOne**: indicates that many instances of the child entity are associated with one instance of the parent entity.

    @Entity
    public class Comment {
        ...

        @ManyToOne(fetch = FetchType.LAZY)
        @JoinColumn(name = "post_id", nullable = false)
        private Post post;
    }

**@ManyToMany**: defines a many-to-many relationship between two entities. It requires an **intermediate** join table to store the relationships between the entities.

    /**
    * sku and inventory is M:N relationship
    * inventory_id indicates which inventories are eligible for placing an order.
    */
    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "sku_inventory",
        joinColumns = @JoinColumn(name = "sku_id"),
        inverseJoinColumns = @JoinColumn(name =
        "inventory_id"))
    private Set<PmsInventory> pmsInventories = new HashSet<>();

#### 7. What is the cascade = CascadeType.ALL, orphanRemoval = true? and what are the other CascadeType and their features? In which situation we choose which one?

**Cascading** means propagating an operation from the owning entity to the related entity. When a record in the owning entity (parent table) is saved, updated or deleted, the change should be reflected in the related entity (child table) as well.

**cascade = CascadeType.ALL** means all operations should be cascaded from the parent entity to the associated child entities.

**orphanRemoval = true** specifies if an entity on the "one" side of a OneToOne or OneToMany relationship is removed (orphaned), then the associated entities on the "many" side should also be removed.

**CascadeType Options**:

**CascadeType.PERSIST**:
Propagates the persist operation to the associated entities.

**CascadeType.MERGE**:
Propagates the merge operation to the associated entities.

**CascadeType.REFRESH**:
Propagates the refresh operation to the associated entities.

**CascadeType.REMOVE**:
Propagates the remove operation to the associated entities.

**CascadeType.DETACH**:
Propagates the detach operation to the associated entities.

#### 8. What is the fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the difference? In which situation you choose which one?

**fetch = FetchType.LAZY**
- If we don't need data from comment, JPA doesn't fetch it. 
- Only fetch data from post. 
- When we need data from comment, then JPA fecth comment data.

**fetch = FetchType.EAGER**
when we fetch post, JPA also fetch comment at the same time.

#### 9. What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?

JPA provides default query methods based on the method names in Spring Data repositories. These default query methods are derived from the method names following a set of naming conventions. 

We can create queries without writing explicit JPQL or SQL, as long as the column names adhere to the specified naming rules.

**For example**, we have a method **findByLastnameOrFirstname(a, b)**, JPA expects that our entity class has columns named lastname and firstname. The parameters a and b will be used as values for the corresponding columns in the generated SQL query.


#### 10. Try to use JPA advanced methods in your class project. In the repository layer, you need to use the naming convention to use the method provided by JPA.
Object-Relational Mapping (ORM) framework can help and simplify the translation between the two paradigms: objects and relational database tables. It is a technique that align programming code with querying and manipulating data from a database, so that instead of writing SQL statements to interact with the database, 

#### 13. type the code, you need to checkout new branch from branch 02_post_RUD, name the new branch with https://github.com/TAIsRich/springboot-redbook/tree/hw05_01_slides_JPQL.

see code

#### 14. What is JPQL?
**JPQL** is Java Persistence Query Language based on SQL syntax defined in JPA. It is used to create queries against entities to store in a relational database. JPQL is developed. But it won’t affect the database directly. It uses class name(Post) instead of table name(posts) in db.

#### 15. What is @NamedQuery and @NamedQueries?
**@NamedQuery** and **@NamedQueries** define named queries in the entity classes. They are pre-defined queries that can be referenced by name and reused in multiple parts of a application.

    @Entity
    @NamedQueries({
        @NamedQuery(
            name = "findUserByUsername",
            query = "SELECT u FROM User u WHERE u.username = :username"
        ),
        @NamedQuery(
            name = "findAllUsers",
            query = "SELECT u FROM User u"
        )
    })
    public class User {
        // entity properties, methods, etc.
    }

Use them:

    TypedQuery<User> query = entityManager.createNamedQuery("findUserByUsername", User.class);
    query.setParameter("username", "grace");
    User user = query.getSingleResult();

#### 16. What is @Query? In which Interface we write the sql or JPQL?

**@Query** is used in Spring Data JPA to define custom queries for repository methods. It allows us to write JPQL or native SQL queries and associate them with specific repository methods.

In the **repository interface**

#### 17. What is HQL and Criteria Queries?
**HQL** (Hibernate Query Language) and **Criteria Queries** are two approaches provided by Hibernate for querying data from a relational database using Java objects.

#### 18. What is EnityManager?
A JPA **EntityManager** manages connection to a database as well as to database operations. 

**EntityManager** is associated with a PersistenceContext. All operations that are performed in a specific session are stored inside the PersistenceContext.

**EntityManager** is the interface to the Persistence Context. All operations on the entity go through the EntityManager. 

We will declare an **EntityManager** object in our
class and mark it with the @PersistenceContext annotation.

**EntityManager** provides a number of methods that perform SELECT, INSERT, UPDATE, and DELETE queries.

#### 19. What is SessionFactory and Session?
In Hibernate, the SessionFactory and Session are key components responsible for managing database connections, performing database operations, and representing the current state of the persistence context.

**SessionFactory** is a factory class for creating Session instances.

**Session** object provides an interface between the application and data stored in the database.

The SessionFactory is typically created once during application startup, while a new Session is opened and closed for each unit of work with the database.

#### 20. What is Transaction? how to manage your transaction?

A **transaction** simply represents a unit of work.
In such case, if one step fails, the whole transaction fails (which is termed as atomicity). A transaction can be described by ACID properties

Transaction **management**:

a. **@EnableTransactionManagement** in main class of the application

b. **@Transactional** in method in the service class.

#### 21. What is hibernate Caching?

**First-level cache**:

Hibernate first level cache is session specific, that’s why when we are getting the same data in same session there is no query fired whereas in other session query is fired to load the data.

**Second-level cache**: 

When an entity instance is looked up by its id and if
second-level caching is enabled for that entity, the following happens:

a. If an instance is already present in the first-level cache, it is returned from there

b. If an instance is not found in the first-level cache, and the corresponding instance state is cached in the second-level cache, then the data is fetched from there and an instance is assembled and returned

c. Otherwise, the necessary data are loaded from the database and an instance is assembled and returned

#### 22. What is the difference between first-level cache and second-level cache?
FIRST LEVEL CACHE SECOND LEVEL CACHE:

- 1 cache is local to the Session object and
cannot be shared between multiple
sessions. 2 cache is maintained at the
SessionFactory level and shared among all
sessions in Hibernate.
- 1 cache is enabled by default and
there is no way to disable it. 2 is disabled by default, but we can enable
it through configuration.
- 1 cache is available only
until the session is open, once the
session is closed, the first level cache is
destroyed. 2 cache is available through
the application’s life cycle, it is only destroyed
and recreated when an application is


#### 23. How do you understand @Transactional? (type and test transactional https://github.com/TAIsRich/tutorial-transaction)

see code

#### 24. Write a simple factory design pattern.

The client code can create factories and use them to create products without knowing the specific implementations of the products. 

    // Product interface
    interface Product {
        void display();
    }

    // Concrete product implementations
    class ConcreteProductA implements Product {
        @Override
        public void display() {
            System.out.println("Product A");
        }
    }

    class ConcreteProductB implements Product {
        @Override
        public void display() {
            System.out.println("Product B");
        }
    }

    // Factory interface
    interface ProductFactory {
        Product createProduct();
    }

    // Concrete factory implementations
    class ConcreteProductAFactory implements ProductFactory {
        @Override
        public Product createProduct() {
            return new ConcreteProductA();
        }
    }

    class ConcreteProductBFactory implements ProductFactory {
        @Override
        public Product createProduct() {
            return new ConcreteProductB();
        }
    }

    // Client code
    public class FactoryPatternExample {
        public static void main(String[] args) {
            // Create factories
            ProductFactory factoryA = new ConcreteProductAFactory();
            ProductFactory factoryB = new ConcreteProductBFactory();

            // Create products using factories
            Product productA = factoryA.createProduct();
            Product productB = factoryB.createProduct();

            // Use the products
            productA.display(); // Output: Product A
            productB.display(); // Output: Product B
        }
    }
