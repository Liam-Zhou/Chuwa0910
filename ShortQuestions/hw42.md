1. List all of the annotations you learned from class and homework to
   annotaitons.md<br>
The new annotations are in the annotations-42.md. <br>


2. Type the Comment feature for the class project.<br>
The code is in the coding folder.<br>


3. In postman, call of the APIs in PostController and CommentController.
![img.png](img.png)
![img_1.png](img_1.png)
<br>


4. what is JPA? and what is Hibernate?<br>
   JPA (Java Persistence API):JPA is a Java EE (Enterprise Edition) and Java SE (Standard Edition) specification that defines a standard interface for object-relational mapping (ORM) in Java applications. ORM is a technique for mapping Java objects to database tables and vice versa, allowing developers to work with databases using Java objects rather than writing SQL queries directly. JPA provides a standardized way to interact with databases, making it easier to switch between different ORM frameworks without changing your application code. JPA is a set of interfaces and specifications, and it does not provide a concrete implementation. Instead, it defines a set of rules and a contract that ORM frameworks should adhere to. Developers can choose from various JPA implementations, with Hibernate being one of the most popular ones.
   Hibernate:Hibernate is an open-source, high-performance ORM framework that implements the JPA specification. It is one of the most widely used ORM frameworks in the Java ecosystem. Hibernate simplifies database access by providing an object-oriented API for querying and manipulating data in the database, rather than writing SQL queries directly. It also offers features like caching, lazy loading, and automatic schema generation. While Hibernate is a JPA implementation, it also provides its own Hibernate-specific features and extensions that go beyond the JPA standard. This allows developers to take advantage of advanced features when needed.<br>


5. What is Hiraki? what is the benefits of connection pool?<br>
   HikariCP is a high-performance JDBC connection pool library for Java applications. It is known for its speed, reliability, and low resource consumption. HikariCP is often used in Java applications, particularly in combination with various Java frameworks and technologies like Spring and Hibernate. Here are some key benefits of using HikariCP or any connection pool:
   Benefits of Connection Pools:Resource Efficiency,Improved Performance,Connection Management,Optimal Resource Usage,Failover and Resilience,Scalability,Reduced Database Load, and, Configuration Flexibility<br>

   
6. What is the @OneToMany, @ManyToOne, @ManyToMany? write some examples.<br>
   @OneToMany:This annotation is typically used in JPA (Java Persistence API) to define a one-to-many relationship between two entities. For example, if you have an entity called Author and another entity called Book, you can use @OneToMany to specify that one author can have many books.<br>
```
@Entity
public class Author {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToMany(mappedBy = "author")
    private List<Book> books;
    
    // ... other fields and methods
}
```
   @ManyToOne: This annotation is also used in JPA to define the other side of a one-to-many relationship. In the example above, you would use @ManyToOne on the Book entity to specify that many books belong to one author. This annotation is used to map the foreign key relationship in the database.<br>
   Example:
   Continuing with the previous example, the Book entity uses @ManyToOne to indicate its relationship with the Author entity.


   @ManyToMany:This annotation is used to define a many-to-many relationship between two entities. In a many-to-many relationship, an instance of one entity can be associated with multiple instances of another entity, and vice versa. For example, if you have entities for Student and Course, you can use @ManyToMany to specify that students can enroll in multiple courses, and each course can have multiple students.<br>
```
@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToMany
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private List<Course> courses;
    
    // ... other fields and methods
}
```

7. What is the cascade = CascadeType.ALL, orphanRemoval = true? and what
   are the other CascadeType and their features? In which situation we choose
   which one?
   CascadeType.ALL: This option indicates that all operations (including persist, merge, remove, refresh, and detach) should be cascaded to the related entity. In other words, when you perform an operation on the owning entity, the same operation will be applied to the related entity or entities.<br>
   orphanRemoval is a Boolean attribute that, when set to true, specifies that if an entity is removed from the collection of the owning entity, it should be deleted from the database. This is used in conjunction with @OneToMany relationships to automatically remove child entities when they are no longer associated with the parent entity.<br>
   Use CascadeType.ALL sparingly because it can lead to unintended consequences, such as unnecessary database operations. Use CascadeType.PERSIST when you want to save new related entities when the owning entity is persisted. Use CascadeType.MERGE when you want changes in the owning entity to be merged into related entities. Use CascadeType.REMOVE when you want to delete related entities when the owning entity is removed. Use CascadeType.REFRESH when you want to refresh related entities when the owning entity is refreshed. Use CascadeType.DETACH when you want to detach related entities when the owning entity is detached.Use orphanRemoval = true when you want to automatically delete child entities when they are removed from the collection of the owning entity.<br>


8. What is the fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the
   difference? In which situation you choose which one?
   FetchType.LAZY:When an association is marked with FetchType.LAZY, it means that the related entities are loaded from the database only when they are explicitly accessed in your code. In other words, the related data is fetched lazily on-demand. FetchType.LAZY is a good choice when you have large associations or when you want to minimize the initial data load for performance reasons. It's particularly useful when you have scenarios where you don't always need the related data and want to defer its retrieval until necessary. Use FetchType.LAZY when you want to avoid unnecessary database queries and reduce the amount of data fetched from the database initially.<br>
   FetchType.EAGER:When an association is marked with FetchType.EAGER, it means that the related entities are loaded immediately and eagerly fetched along with the owning entity when queried. This means that all related data is fetched from the database in a single query. FetchType.EAGER is suitable when you consistently need the related data whenever the owning entity is accessed. It's a good choice when you want to ensure that the related data is always available and don't want to incur the overhead of additional queries to fetch it lazily. However, you should be cautious when using FetchType.EAGER with large or deep object graphs, as it can lead to excessive data retrieval and performance issues.<br>


9. What is the rule of JPA naming convention? Shall we implement the method by
   ourselves? Could you list some examples?<br>
   JPA (Java Persistence API) provides a set of naming conventions that help map Java entity classes to database tables and columns without the need for explicit configuration. These conventions simplify the development process, as JPA can infer the mappings based on the naming of entity classes and their fields.<br>
```
@Entity
@Table(name = "people")
public class Person {
    // ...
}
```

```
@Entity
public class Person {
    @Id
    private Long personId;
    // ...
}
```

```
@Entity
public class Student {
    @ManyToMany
    @JoinTable(name = "student_course",
               joinColumns = @JoinColumn(name = "student_id"),
               inverseJoinColumns = @JoinColumn(name = "course_id"))
    private List<Course> courses;
    // ...
}
```


10. Try to use JPA advanced methods in your class project. In the repository layer,
    you need to use the naming convention to use the method provided by JPA.
![img_2.png](img_2.png)
11. (Optional) Check out a new branch(https://github.com/TAIsRich/springboot-red
    book/tree/hw02_01_jdbcTemplate) from branch 02_post_RUD, replace the dao
    layer using JdbcTemplate.
12. (Optional) use JDBC to read the data from database.
```
package com.chuwa.redbook;

import java.sql.*;

public class JdbcExample {
    private static final String URL = "jdbc:mysql://localhost:3306/redbook?useSSL=false&serverTimezone=UTC";
    private static final String USER = "root";
    private static final String PASSWORD = "";
    public static void main(String[] args) {
        Connection connection = null;
        PreparedStatement statement = null;
        ResultSet resultSet = null;
        try {
            connection = DriverManager.getConnection(URL, USER, PASSWORD);
            String sql = "SELECT * FROM authors";

            statement = connection.prepareStatement(sql);

            resultSet = statement.executeQuery();

            while (resultSet.next()) {
                int id = resultSet.getInt("id");
                String name = resultSet.getString("name");
                System.out.println("ID: " + id + ", Name: " + name);
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        } finally {
            try {
                resultSet.close();
                statement.close();
                connection.close();
            } catch (SQLException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
```
13. type the code, you need to checkout new branch from branch 02_post_RUD,
    name the new branch with https://github.com/TAIsRich/springboot-redbook/
    tree/hw05_01_slides_JPQL.
The code in the coding folder
14. What is JPQL?<br>
    JPQL (Java Persistence Query Language) is a query language used in Java applications to perform database queries and manipulate data in a database-agnostic way. It is a part of the Java Persistence API (JPA), which is a Java standard for object-relational mapping (ORM). JPQL allows developers to write queries that target JPA-managed entities and their relationships, abstracting away the specifics of the underlying database.<br>


15. What is @NamedQuery and @NamedQueries?<br>
    @NamedQuery and @NamedQueries are annotations in the Java Persistence API (JPA) used to define and manage named queries for entities. Named queries are predefined, named SQL-like queries that can be used to retrieve data from a database in a more structured and maintainable way. These queries are associated with a specific entity and can be reused throughout the application.<br>


16. What is @Query? In which Interface we write the sql or JPQL?<br>
In JPA (Java Persistence API), @Query is an annotation used to define custom SQL or JPQL (Java Persistence Query Language) queries for database operations. You can use @Query to write your own database queries and execute them through a JPA repository or directly in a JPA entity repository interface.<br>
Repository Interface:The custom queries defined with @Query are typically placed in a repository interface that extends a JPA repository interface like JpaRepository. You can also define custom query methods without @Query using method naming conventions provided by Spring Data JPA.<br>


17. What is HQL and Criteria Queries?<br>
HQL (Hibernate Query Language) and Criteria Queries are two different approaches for querying databases when using Hibernate, an Object-Relational Mapping (ORM) framework for Java. Both HQL and Criteria Queries allow you to interact with your database in an object-oriented way, abstracting away the details of the underlying SQL.<br>


18. What is EnityManager?<br>
The EntityManager is a core component in the Java Persistence API (JPA), which is a Java specification for object-relational mapping (ORM). It plays a central role in managing entity objects and their interactions with a relational database. The EntityManager is typically provided by a JPA implementation, such as Hibernate, EclipseLink, or OpenJPA, and is used to perform various database operations in a Java application.<br>

    
19. What is SessionFactory and Session?<br>
SessionFactory and Session are core components in Hibernate, which is an Object-Relational Mapping (ORM) framework for Java. These components are crucial for managing the interaction between Java objects (entities) and a relational database.<br>
SessionFactory:The SessionFactory is a factory class responsible for creating and managing Session instances in Hibernate. It is typically built once during the application's initialization and serves as a long-lived, thread-safe object.<br>
Session:A Session represents a single-unit-of-work in Hibernate. It is a short-lived object that is typically created, used, and then discarded within a single method or transaction. Session instances are not thread-safe, so they should not be shared between threads. The Session is responsible for managing the lifecycle of persistent objects (entities), executing database operations, and maintaining the first-level cache (also known as the "persistence context").<br>


20. What is Transaction? how to manage your transaction?<br>
A transaction is a fundamental concept in database management systems (DBMS) and is used to ensure data consistency and integrity in a database. A transaction is a sequence of one or more database operations (such as inserts, updates, or deletes) that are executed as a single, indivisible unit of work. Transactions follow the ACID properties, which stand for Atomicity, Consistency, Isolation, and Durability.<br>
Transaction Manager: Java EE (Enterprise Edition) and Spring Framework provide built-in transaction management capabilities. You can configure a transaction manager that handles the initiation, commit, and rollback of transactions. Common transaction managers include JTA (Java Transaction API) for Java EE applications and the Spring PlatformTransactionManager for Spring-based applications.<br>
Annotations: Many Java frameworks, such as Java EE and Spring, offer annotations to simplify transaction management. For example, in Spring, you can use @Transactional to mark methods or classes as transactional.<br>


21. What is hibernate Caching?<br>
Hibernate caching is a mechanism that improves the performance and efficiency of database interactions in Hibernate, an Object-Relational Mapping (ORM) framework for Java. Caching involves storing frequently accessed data in memory, reducing the need to repeatedly query the database. Hibernate provides several levels of caching to optimize database operations.<br>


22. What is the difference between first-level cache and second-level cache?<br>
The key difference between first-level cache and second-level cache in Hibernate is their scope and lifecycle. First-level cache is session-specific and exists for the duration of a single Session, while second-level cache is shared and can persist data across multiple sessions and even different parts of an application. The choice between these caching mechanisms depends on your specific use case and performance optimization goals.<br>


23. How do you understand @Transactional? (不要clone，要⾃⼰抄写并测试
    transactional，https://github.com/TAIsRich/tutorial-transaction)
The code in the coding folder.
24. Write a simple factory design pattern.
```
interface Product {
    void display();
}

class ConcreteProductA implements Product {
    @Override
    public void display() {
        System.out.println("This is Concrete Product A");
    }
}

class ConcreteProductB implements Product {
    @Override
    public void display() {
        System.out.println("This is Concrete Product B");
    }
}

interface Factory {
    Product createProduct();
}

class ConcreteFactoryA implements Factory {
    @Override
    public Product createProduct() {
        return new ConcreteProductA();
    }
}

class ConcreteFactoryB implements Factory {
    @Override
    public Product createProduct() {
        return new ConcreteProductB();
    }
}

public class FactoryPatternExample {
    public static void main(String[] args) {
        Factory factoryA = new ConcreteFactoryA();
        Product productA = factoryA.createProduct();
        productA.display();

        Factory factoryB = new ConcreteFactoryB();
        Product productB = factoryB.createProduct();
        productB.display();
    }
}
```