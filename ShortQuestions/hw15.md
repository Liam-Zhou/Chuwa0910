# hw14 - Ke Chen - testing

## 1.  List all of the new learned annotations to your annotations.md

find in ShortQuestions file : annotations.md






## 2.  what is selenium?

Selenium is <u> a tool used for automating web application testing to simulate user behaviors such as clicking, entering text, selecting options, and more within a browser.</u>

允许开发人员编写自动化测试脚本，模拟用户在浏览器中进行各种交互的行为，比如点击、输入文字、选择选项等。




## 3.  what is cucumber?

Cucumber is <u>a testing tool used for Behavior-Driven Development (BDD) with Given-When-Then pattern.</u>

Given-When-Then pattern:
- Given: The "Given" keyword is used to <u>set up the initial context for a scenario</u>  初始条件
- When: The "When" keyword is used to <u>describe the action or event that triggers the behavior to be tested.</u> 特定的行为或操作
- Then: The "Then" keyword is used to <u>specify the expected outcome or result of the scenario.</u>     预期的结果


![cucumber]()

软件开发方法：
TDD(Test-Driven Development): 开发人员在编写实际代码之前，先编写针对特定功能或模块的测试用例.
DDD(Data-Driven Dvelopment): 基于数据进行决策和开发,持续收集和分析数据，然后根据这些数据作出相应的调整和改进
BDD(Behavior-Driven Development): 通过描述系统行为和预期结果的方式来推动软件开发。




## 4.  what is JMeter?

Apache JMeter is <u>a application designed for load testing, performance testing.</u> 

JMeter <u>can simulate simulate heavy loads to assess the performance under different conditions.</u> 

can simulate various load types, including static and dynamic resources, database, FTP, SOAP/REST web services, and more.

It provides visual test results that can generate charts and reports to help users analyze performance data. JMeter also supports distributed testing, which can be run on multiple computers to simulate larger loads.

JMeter可以模拟多种负载类型，包括静态和动态资源、数据库、FTP、SOAP/REST Web Services等。

它提供了可视化的测试结果，可以生成图表和报告，帮助用户分析性能数据。JMeter还支持分布式测试，可以在多个计算机上运行以模拟更大的负载。




## 5.  What is the lifecircle of Junit?

1. Class-Level Setup (BeforeClass)
2. Test Setup (Before)
3. Test Execution (Test method)
4. Test Cleanup (After)
5. Repeat the above steps for each test method in the class
6. Class-Level Cleanup (AfterClass)

![JUint lifecycle](images/hw14/JUint%20lifecycle.png)


The lifecycle of JUnit includes the following phases:

1. Class-level Setup(BeforeClass): JUnit invokes any methods annotated with `@BeforeClass/@BeforeAll` once for the entire test class to perform setup tasks, such as setting up database connections or initializing common resources.

2. Test Setup(Before): Before the execution of each test method, JUnit invokes methods annotated with `@Before/@BeforeEach`, such as creating or configuring objects needed for the test.

3. Test Execution: JUnit executes the test method annotated with `@Test`.

4. Test Cleanup (After): After the test method has executed, JUnit invokes methods annotated with `@After/@AfterEach`, such as releasing resources or cleaning up objects created during the test.

5. Class-Level Cleanup (AfterClass): At the end of the test suite, JUnit invokes methods annotated with `@AfterClass/@AfterAll` once for the entire test class to perform cleanup tasks, such as release any resources acquired during the class-level setup.




## 6. Is @BeforeAll method should be Class level(static)?

<u> Yes. Because it is invoked once for the entire test class and used to perform setup task, such as setting up database connections or initializing common resources.</u>

@BeforeAll 修饰的method是static method，因为他是class level的。

```java
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

public class MyTestClass {
    @BeforeAll
    static void classLevelSetup() {
        // Perform class-level setup tasks here, e.g., initialize shared resources.
    }

    @Test
    void testMethod1() {
        // Test method 1
    }

    @Test
    void testMethod2() {
        // Test method 2
    }
}
```




## 7. What is Mockito? and what is its limitations?  what kind of tools can give help?

**What is Mockito?**

Mockito is <u>a framework for creating and using mock objects in unit testing for the purpose of simulating the behavior of real objects. </u>

Mock objects are used to simulate the behavior of real objects or components that a class depends on, such as dependencies, collaborators, or external systems.

Mockito allows you to isolate the code you want to test by replacing these dependencies with mock objects, enabling more controlled and focused testing.


**what is its limitations?**

1. Cannot Mock Final Classes and Methods

2. Limited Support for Static and Private Methods: Mockito has limited support for mocking static and private methods. You may need additional tools or libraries to mock these types of methods.

3. Limited Support for Spying: While Mockito supports the creation of spy objects, it may not work correctly in all scenarios, and behavior may differ from that of true partial mocking.


**what kind of tools can give help?**
1. PowerMock: An extension of Mockito that enables mocking of static methods, final classes, and private methods.

2. EasyMock: EasyMock is another Java-based mocking framework that can be used alongside Mockito. It provides similar mocking and verification features.

3. JMockit: A comprehensive mocking library for Java that allows mocking of static methods, final classes, and private methods.




## 8.  What is @Mock and what is @InjectMocks?

**What is `@Mock`?**

This annotation is used to <u>create a mock object in a test class</u>. 

It marks a field in a test class as a mock object, allowing Mockito to create an instance of the specified type that can be used within the test


**what is `@InjectMocks`?**

The @InjectMocks annotation is used to <u>create an instance of the class under test and inject the dependencies annotated with @Mock into this instance.</u>

```java
// a service and a controller class:
public class SomeService {
    public String greet() {
        return "Hello!";
    }
}

public class SomeController {
    private SomeService someService;

    public String greet() {
        return someService.greet();
    }
}

// test SomeController and mock SomeService
import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.when;

public class SomeControllerTest {
    @Mock
    private SomeService someService; // Mocking SomeService
    
    @InjectMocks
    private SomeController someController; // Injecting mocked SomeService into SomeController

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this); // Initialize mocks
    }

    @Test
    public void testGreet() {
        // Given
        when(someService.greet()).thenReturn("Mock Hello!"); // Stubbing the method

        // When
        String greeting = someController.greet();

        // Then
        assertEquals("Mock Hello!", greeting); // Assert the result
    }
}
```




## 9.  What is the stubbing (define behaviors)?

Stubbing, in the context of testing and mocking frameworks like Mockito, refers to <u>the process of defining specific behaviors(throw exception) or return values for method / calls on mocked objects</u> during test setup.

When creating mock objects, you can set expectations on method calls using stubbing. 

For example, you can specify what a method should return when it's called with specific arguments or define certain behaviors like throwing exceptions. 

This process of defining expected behaviors of mocked methods to control their responses during testing is referred to as stubbing.

It allows you to simulate various scenarios and test how your code handles those situations without executing the actual code implementation.

![set up expectations]()

Here's an example of stubbing in Mockito to illustrate the concept:
```java
import static org.mockito.Mockito.*;

public class MyTest {
    @Mock
    private MyDependency mockDependency;

    public void myTestScenario() {
        // Stubbing: Define behavior for the mock method
        when(mockDependency.getData()).thenReturn("Mocked Data");

        // The test code that uses mockDependency
        String result = mockDependency.getData();

        // Assertion: Check that the result matches the expected behavior
        assert(result.equals("Mocked Data"));
    }
}
```
In this example:
1. `mockDependency` is a mock object.
2. `when(mockDependency.getData()).thenReturn("Mocked Data")` is the stubbing step where we define that when the `getData` method of `mockDependency` is called, it should return "Mocked Data."
3. During the test, when `mockDependency.getData()` is called, it returns "Mocked Data" as expected.




## 10. what is Mockito ArgumentMatchers?

Mockito ArgumentMatchers <u>are utilities provided by the Mockito to define flexible argument matching during stubbing and verification in tests, such as eq(), any(), anyInt() and so on.</u>

1. eq(): This matcher is used to match an argument with a specific value. For example, `eq(42)` matches the argument that is equal to 42.

2. any(): This matcher matches any argument, regardless of its value. For example, `any(String.class)` matches any String argument.

3. anyInt(), anyDouble(), anyBoolean(), etc.: These matchers match arguments of specific primitive types, such as int, double, or boolean.

4. anyList(): This matcher matches a list of arguments.

5. eqList(): This matcher matches a list of arguments with specific values. For example, `eqList(1, 2, 3)` matches a list with elements 1, 2, and 3.

6. contains(), argThat(): These matchers allow you to specify custom argument matching logic. You can define your own matcher by implementing the `ArgumentMatcher` interface or using a lambda expression. For example, `argThat(list -> list.size() > 0)` matches a list with at least one element.

```java
import static org.mockito.Mockito.*;

// any() - matches any argument of any type
when(mockedObject.method(any())).thenReturn(someValue);

// eq() - matches a specific value
when(mockedObject.method(eq("specificValue"))).thenReturn(someOtherValue);

// anyInt() - matches any integer argument
when(mockedObject.method(anyInt())).thenReturn(42);

// anyString() - matches any string argument
when(mockedObject.method(anyString())).thenReturn("Hello");

// isNull() - matches null arguments
when(mockedObject.method(isNull())).thenReturn("Null argument");

// isNotNull() - matches non-null arguments
when(mockedObject.method(isNotNull())).thenReturn("Non-null argument");

// You can also combine matchers
when(mockedObject.method(anyInt(), eq("specificString"))).thenReturn("Combined matchers");

// Verifying invocations using matchers
// verifies that the method of mockObject was called with the argument anyInt/specificValue.
verify(mockedObject).method(anyInt());
verify(mockedObject).method(eq("specificValue"));
```



## 11. what is Hamcrest Matchers?

Hamcrest Matchers is <u>a library for writing assertions or matchers in unit test, such as is(), greaterThan(), emptyOrNullString() to perform assertions.</u> 

Here's a simple example of how Hamcrest Matchers can be used with JUnit:

```java
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;

// Assertion using Hamcrest Matchers
int number = 10;
assertThat(number, is(10)); // Verifies if 'number' is equal to 10
assertThat(number, greaterThan(5)); // Verifies if 'number' is greater than 5
assertThat("Hello", is(not(emptyOrNullString()))); // Verifies if the string is not empty or null
```
In this example, is(), greaterThan(), not(), and emptyOrNullString() are some of the Hamcrest matchers used to perform assertions. 




## 12. do you know @spy? what is difference between @spy and @Mock?

**what is the @spy?**

`@Spy` is used to <u>initialze a real instance of the test class, but still can do stubbing to define specific behaviors or return values for method calls on spy objects.</u>

```java
public class ExampleService {
    public String greet() {
        return "Hello, World!";
    }
}

// Using @Mock
@ExtendWith(MockitoExtension.class)
class MockExampleServiceTest {
    @Mock
    private ExampleService exampleService;

    @Test
    void testGreet() {
        when(exampleService.greet()).thenReturn("Mocked Hello");
    }
}


// Using @Spy
@ExtendWith(MockitoExtension.class)
class SpyExampleServiceTest {
    @Spy
    private ExampleService exampleService = new ExampleService();

    @Test
    void testGreet() {
        // Stubbing the greet() method
        doReturn("Spied Hello").when(exampleService).greet();
    }
}
```


**@Spy VS @Mock?**

1. Object Creation
- @Mock: create a mock object of the class
- @Spy: initializes a real instance of the class

2. Defining Behavior:
- @Mock: define behavior for methods using when().thenReturn()
- @Spy: define behavior for methods using doReturn.when()




## 13. What is assertion?

An assertion in software testing is <u>a statement or expression to verify if the actual behavior of the program matches the expected behavior defined by the test case, such as asserEquals(), assertTrue(), assertNull() and so on.</u>

![assertion]()

1. assertEquals(expected, actual): Compares if the expected value is equal to the actual value. This is used to verify that two values are equal.

2. assertNotEquals(unexpected, actual): Verifies that the unexpected value is not equal to the actual value.

3. assertSame(expected, actual): Checks if the expected object is the same as the actual object (i.e., they reference the same object in memory).

4. assertNotSame(unexpected, actual): Ensures that the unexpected object is not the same as the actual object.

5. assertTrue(condition): Validates that the given condition is true. This is commonly used to check if a Boolean expression or condition is true.

6. assertFalse(condition): Checks that the given condition is false.

7. assertNull(object): Verifies that the provided object is null.

8. assertNotNull(object): Checks that the provided object is not null.

9. assertArrayEquals(expectedArray, actualArray): Compares two arrays to ensure that they are equal, element by element.

10. assertThrows(expectedException, executable): Checks if a specific exception is thrown when the executable code block is executed. This is used for testing exception handling.

11. assertDoesNotThrow(executable): Ensures that no exception is thrown when the executable code block is executed.

12. assertThat(value, matcher): Used in libraries like Hamcrest to create custom and expressive assertions with various matchers.

13. fail(message): Manually triggers a test failure with an optional error message. This is useful for marking tests as failed when certain conditions are not met.




## 14. If you have developed a new feature, how many types of tests for this feature? and what kind of tests are written by you?    what is the purpose of each type of tests?

written by Developers: Unit test and Integration test.

1. **Unit Tests**:
   - **Purpose**: Testing the smallest testable units of a program, such as functions or methods
   - **Written by**: Developers.
   - **Purpose**: Verify the correctness of individual components

2. **Integration Tests**:
   - **Purpose**: Testing the interactions between multiple components or modules
   - **Written by**: Developers or QA((Quality Assurance)) engineers.
   - **Purpose**: Verify that the collaboration between components or modules is correct

3. **Regression Tests**:
   - **Purpose**: After modifying the program or environment, re-run previously run tests to confirm that no new errors have been introduced
   - **Written by**: QA engineers.
   - **Purpose**: Ensure that after changes, existing functionality is still correct

4. **Performance Tests**:
   - **Purpose**: Testing the performance and response time of a system under a specific workload
   - **Written by**: QA engineers or performance testing specialists.
   - **Purpose**: Verify the performanceand efficiency of the system -> 200ms

5. **Load Tests**:
    - Purpose: Load tests assess how the application performs under expected loads and beyond. They help determine the maximum capacity of the system before performance degrades.
    - Written by: Performance engineers or test engineers.
    - Purpose: Verify that the application can handle expected concurrent user loads and beyond without significant degradation.

6. **Stress Tests**:
    - Purpose: Testing the stability and reliability of a system by simulating an environment with workloads or data volumes beyond normal levels
    - Written by: Performance engineers or test engineers.
    - Purpose: Ensure that the system can still work normally under high pressure -> 2k QPS

7. **User Acceptance Tests (UAT)**:
   - **Purpose**: The end user tests the software to confirm that it can perform the required tasks under actual conditions
   - **Written by**: QA engineers, users, or stakeholders.
   - **Purpose**: Ensure that the software meets user needs and expectations
 
![type of testing]()




## 15. Add unit test for CommentServiceImpl, the coverage should be 100%.

**find in Coding file : hw15-testing - CommentServiceImplTest**

![commentServiceImpl_test]()




## 16. write Integration tests for PostController. The tests should cover all scenarios.

**find in coding file : hw15-testing - PostControllerTest**

![postController_test]()