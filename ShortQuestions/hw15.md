1. List all of the new learned annotations to your annotations.md

2. What is selenium?

    Selenium is an open-source web automation tool primarily used for automating web applications for testing purposes. It provides a set of tools and libraries that can interact with and control web browsers, allowing testers to automate web application testing across different browsers and platforms.

3. What is cucumber?

    Cucumber is a software tool used for testing other software. It runs automated acceptance tests written in a behavior-driven development (BDD) style. Cucumber reads executable specifications written in plain language and validates that the software does what those specifications say.

4. What is JMeter?

    Apache JMeter is an open-source Java application designed to load test functional behavior and measure performance. Originally designed for testing Web Applications, it has since expanded to other test functions.

5. What is the lifecircle of Junit?

    JUnit is a popular unit testing framework for Java. The lifecycle of a JUnit test includes:

    1. @BeforeClass: Run once before any of the test methods in the class, must be static.
    2. @Before: Run before each test method.
    3. Test methods: The actual test cases.
    4. @After: Run after each test method.
    5. @AfterClass: Run once after all the test methods in the class, must be static.

6. Is @BeforeAll method should be Class level(static)?

    In JUnit 5, @BeforeAll is an annotation used to signal that the annotated method should be executed before all tests in the current test class. It should be applied to static methods.

7. What is Mockito? and what is its limitations? what kind of tools can give help?

    Mockito is a popular mocking framework for unit tests in Java. It allows us to create mock objects and define their behavior during tests. Limitations include:

    1. Difficulty mocking static methods, constructors, and private methods (though recent versions have started addressing these).
    2. Can't mock final classes or methods.
    3. Requires a bit of learning to use effectively.
    
    Tools like PowerMock can help overcome some of Mockito's limitations, especially in mocking static methods and final classes.

8. What is @Mock and what is @InjectMocks?

    1. @Mock: This annotation is used to create and inject mocked instances without having to call Mockito.mock explicitly.
    2. @InjectMocks: This annotation is used to create an instance of the class and injects the mocks that are created with the @Mock annotations into this instance.

9. What is the stubbing (define behaviors)?

    In Mockito, stubbing refers to the practice of defining the behavior of mock objects, i.e., what responses should be returned when specific methods are called.

10. What is Mockito ArgumentMatchers?

    Argument matchers in Mockito allow us to flexibly specify arguments that are passed to method calls on mock objects, enabling stubbing or verification with non-specific arguments.

11. What is Hamcrest Matchers?

    Hamcrest is a framework for writing matcher objects, allowing for more readable and flexible test conditions in assertions. It's often used with JUnit and other testing frameworks.

12. Do you know @spy? What is difference between @spy and @Mock?

    1. @Spy: Used to create a spy instance. Spies represent real objects with some methods being mocked/stubbed.
    2. @Mock: Used to create a complete mock object. All methods of a mock are stubbed and have no original behavior.
The main difference is that a spy defaults to calling the actual implementation of a method, while a mock defaults to doing nothing.

13. What is assertion?

    In testing, an assertion is a statement that checks whether a condition is true. If the condition is false, the test fails. Assertions are key to validating the behavior of a method against expected outcomes.

14. If you have developed a new feature, how many types of tests for this feature? And what kind of tests are written by you? What is the purpose of each type of tests?

    1. Unit Tests: Written by developers, focus on individual units of source code.
    2. Integration Tests: Ensure different parts of the application work together.
    3. Functional Tests: Validate the software against functional requirements.
    4. End-to-End Tests: Test the entire application in an environment that mimics real-world use.
    5. Performance Tests: Check the performance and behavior under various conditions.
    
    The purpose of each type varies from verifying the correctness of individual units, integration between components, to assessing the overall performance and user experience.

15. Add unit test for CommentServiceImpl, the coverage should be 100%.

16. write Integration tests for PostController. The tests should cover all scenarios.