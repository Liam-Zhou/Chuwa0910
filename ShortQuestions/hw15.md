*********************************
Q1. List all of new learned annotations to your annotations.md

See annotation.md
*********************************
Q2. What is selenium?

Selenium is a framework that is widely used for automating web browsers.

It provides a set of tools and libraries for web application testing, primarily in the context of functional and regression testing.
Selenium allows you to automate interactions with web applications by simulating user actions, such as clicking buttons, entering text, and navigating between pages.
*********************************
Q3. What is cucumber?

Testing framework that supports Behavior-Driven Development (BDD).
Used for automating acceptance tests and facilitaing collaboratiion between technical and non-technical team in software development.
Cucumber allows the execution of feature documentation written in business-facing text.
*********************************
Q4. What is JMeter?

Apache JMeter. Designed for load testing, performance testing and functional testing of applications.

It is primarily used to simulate user interactions with web services, databases, and other network protocols to assess the performance, scalability, and reliability of software systems.
JMeter allows you to create and run test plans that mimic real user behavior, enabling you to measure how an application performs under different loads and conditions.
*********************************
Q5. What is the life circle of Junit?

Test class creation > Test fixture setup > Test Execution > text fixture teardown > Test runner > test report & report > assertions and failure handling > repeat
*********************************
Q6. Is @BeforeAll method should be Class level(static)?

Yes, it should be static.

In JUnit 5, the @BeforeAll annotation is used to indicate a method that should be executed before all the test methods in a test class.
*********************************
Q7. What is Mockito? and what is its limitations? what kind of tools can give help?

It allows you to simulate the behavior of dependencies, enabling isolated testing.
Limitations include inability to mock static, final, or private methods.
Tools like PowerMock and Spock can address these limitations and enhance mocking capabilities.
*********************************
Q8. What is @Mock and what is @InjectMocks?

@Mock is used to create a mock object for a specific class or interface. It allows you to simulate the behavior of dependencies or collaborators in a unit test by providing mock implementations.

@InjectMocks is used to inject the mock objects created with @Mock into the class under test. It simplifies the process of injecting mock dependencies into the target class, making it easier to perform unit testing with mocked dependencies.
*********************************
Q9. What is the stubbing (define behaviors)?

"Stubbing" refers to the process of defining the behavior of a mock object when a specific method is called on it.
When you stub a method, you specify what the method should return or what it should do when invoked in a test case.
This allows you to control the behavior of the mock object and simulate specific conditions or responses during testing.
*********************************
Q10. What is Mockito ArgumentMatchers

ArgumentMatchers is a class that provides static methods for matching method arguments in Mockito.
*********************************
Q11. What is Hamcrest Matchers


It can create expcessive and readable assertions in testing. It provides a library of predefined matchers for common typs and a flexible API for
creating custom matchers to suit specific testing needs.
*********************************
Q12. Do you know @spy? what is difference between @spy and @Mock?

@Spy:

1. The @Spy annotation is used to create a spy object. Spy objects are real instances of the class or interface being spied on.

2. When you annotate a field with @Spy, it creates a real instance of the class and allows you to interact with its actual behavior. You can stub or verify method calls on a spy object, and it will execute the real method code.

3. @Spy is typically used when you want to partially mock an object, retaining its real behavior while mocking specific methods.


@Mock:
1. The @Mock annotation is used to create a mock object. Mock objects are used to simulate the behavior of dependencies or collaborators in your unit tests.
2. When you annotate a field with @Mock, it creates a new instance of the class or interface being mocked. The methods of this object are not executed; instead, they return default values (e.g., null for reference types, 0 for integers).
3. @Mock is typically used when you want to isolate the class under test and don't want any actual behavior from the mocked object.
*********************************
Q13. What is assertion?

An assertion is a statement that evaluates to true or false.
*********************************
Q14. If you have developed a new feature, how many types of tests for this feature? and what kind of tests are written by you? what is the purpose of each type of tests?

Unit tests: test individual units of code in isolation.
Integration tests: test how multiple units of code work together.
Functional tests: test the functionality of the application from the user's perspective.

Unit tests are written by developers to test individual units of code in isolation.
Integration tests are written by developers to test how multiple units of code work together.
Functional tests are written by QA engineers to test the functionality of the application from the user's perspective.
*********************************
Q15. Add unit test for CommentServiceImpl, the coverage should be 100%.

See CommentServiceImplTest.java
*********************************
Q16. Write Integration tests for PostController. The tests should cover all scenarios.

See PostControllerIntegrationTest.java
*********************************


