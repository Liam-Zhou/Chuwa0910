2.
Selenium is a powerful tool for controlling a web browser through a program. It's functional for all browsers, works on all major OS, and is available in various languages, including Python, Java, and C#.

3.
Cucumber is a testing tool that supports Behavior Driven Development (BDD). It enables developers, testers, and non-technical participants to define software behavior without delving into the code. Cucumber facilitates writing test scenarios using the Gherkin language, which is a plain English, human-readable format.

4.
JMeter, officially known as Apache JMeter, is an open-source tool designed for load testing and measuring the performance of various services, with a focus on web applications.

5.
A lifecycle method is any method that is annotated with @BeforeAll, @AfterAll, @BeforeEach, or @AfterEach annotation. The lifecycle methods execute before or after executing the actual test methods

6.
Yes, in JUnit 5, the @BeforeAll method must be static by default because it's executed only once before all test methods in the class, at the class level, rather than at the instance level. Similarly, the @AfterAll method, which runs once after all tests in the test class, also needs to be static

7.
Mockito is a popular mocking framework for Java. Mocking is a technique used in unit testing to simulate the behavior of real objects. Using Mockito, you can mock classes or interfaces, record and verify interactions on them, stub out behavior, and more.

limitations:
It can not mock static methods.
Classes, constructors and private methods can not be mocked

Supporting Tools:
PowerMock
JUnit or TestNG

8.
@Mock is used to create mocks that are needed to support the testing of the class to be tested. @InjectMocks is used to create class instances that need to be tested in the test class.

9.
Stubbing is a technique used in unit testing to control the behavior of dependencies or external services so that the component under test can be tested in isolation. In the context of mock objects, stubbing refers to defining the behavior of a mock so that it returns a specific value or throws a specific exception when certain methods are called on it.

10.
ArgumentMatchers allow us flexible verification or stubbing. If a method has more than one argument, we can't just use ArgumentMatchers for only some of the arguments. Mockito requires that we provide all arguments either by matchers or exact values

11.
Hamcrest is a framework that assists writing software tests in the Java programming language. It supports creating customized assertion matchers ('Hamcrest' is an anagram of 'matchers'), allowing match rules to be defined declaratively

12.
Mocks are used to create fully mock or dummy objects. It is mainly used in large test suites. Spies are used for creating partial or half mock objects

13.
In the context of software testing and development, an assertion is a statement or condition that checks whether a specific condition holds true or not. If the condition doesn't hold, an assertion failure occurs, which typically results in the interruption of the program's normal flow or the termination of the testing process.

14.

Unit Tests:
Purpose: To validate that individual units or components of the software work as intended.
Details: These tests are usually automated and test individual methods, classes, or functions in isolation from the rest of the application. Mock objects or stubs might be used to simulate other parts of the application.

Integration Tests:
Purpose: To ensure different components or systems work correctly when integrated.
Details: These tests focus on the interactions between modules or services. They can be broad (testing the interaction between large components) or narrow (testing the interaction between two small components).

Usability Tests:
Purpose: To ensure the product is user-friendly and intuitive.
Details: Typically, real users are involved in such tests to evaluate the system's user interface and overall user experience.

Regression Tests:
Purpose: To ensure new changes haven't negatively impacted existing functionality.Details: These tests are usually automated and are run after each new deployment or change.

Exploratory Tests:
Purpose: To discover defects or behaviors that weren't anticipated.
Details: Testers explore the application without a fixed plan, leveraging their experience and intuition.
