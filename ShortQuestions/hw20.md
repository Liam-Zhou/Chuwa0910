1. Write up Example code to demonstrate the three foundmental concepts of OOP. (reference Code Demo repo as example) <br>
Encapsulation is one of the four core principles of OOP and refers to the bundling of data (attributes or fields) and methods 
(functions) that operate on that data into a single unit known as a class. It restricts direct access 
to some of an object's components, providing control over the object's state and behavior.<br>
Polymorphism is another fundamental OOP concept that allows objects of different classes to be treated 
as objects of a common superclass. It enables you to write code that can work with objects of various 
classes in a uniform way, promoting code reusability and flexibility.<br>
Inheritance is a core concept in OOP that allows you to create a new class (subclass or derived class) by 
inheriting properties and behaviors (fields and methods) from an existing class (superclass or base class). 
The subclass can extend or modify the inherited functionality.<br>
I define two class. Pareant class is Car and Children class is SportCar.
    ```
    public class Car{
        private int id;
        private String Brand;
        private String year;
    
        public int getId() {
            return id;
        }
    
        public void setId(int id) {
            this.id = id;
        }
    
        public String getBrand() {
            return Brand;
        }
    
        public void setBrand(String brand) {
            Brand = brand;
        }
    
        public String getYear() {
            return year;
        }
    
        public void setYear(String year) {
            this.year = year;
        }
    }
    ```
    
    ```
    public class SportCar extends Car{
        private double price;
        private double milesPerHour;
    
        public double getPrice() {
            return price;
        }
    
        public void setPrice(double price) {
            this.price = price;
        }
    
        public double getMilesPerHour() {
            return milesPerHour;
        }
    
        public void setMilesPerHour(double milesPerHour) {
            this.milesPerHour = milesPerHour;
        }
    }
    ```
    For encapsulation, car class has private attributes such as id and year and provide public methods. 
    For Polymorphism, Car car = new SportCar(); using parent reference to point children object. 
    For Inheritance, SportCar as a children class can extend Car attributes. <br>

2. What is wrapper class in Java and Why we need wrapper class? <br>
A wrapper class is a class that allows you to represent primitive 
data types as objects. In Java, there are eight primitive data types: 
byte, short, int, long, float, double, char, and boolean. Wrapper 
classes provide a way to work with these primitive data types as if 
they were objects. Eight wrapper classes is in java such as 
Byte: Represents a byte value. Short: Represents a short value. 
Integer: Represents an integer value. Long: Represents a long value. 
Float: Represents a floating-point value. Double: Represents a 
double-precision floating-point value. Character: Represents a 
character value. Boolean: Represents a boolean value. 
In Java, autoboxing and unboxing make it easier to work with wrapper 
classes, as they automatically convert between primitive types and 
their corresponding wrapper classes when needed.<br>


3. What is the difference between HashMap and HashTable?<br>
HashMap and Hashtable are both data structures in Java used to 
store key-value pairs.If you need thread safety, you can use 
Hashtable, but be prepared for potential performance trade-offs. 
In most cases, HashMap is the preferred choice due to its better 
performance and flexibility. If thread safety is a concern with 
HashMap, you can use Collections.synchronizedMap() to wrap a HashMap 
and make it. synchronized. HashMap allows null values both for keys 
and values. You can have a key-value pair with a null key or a null value.
Hashtable does not allow null keys or values. Attempting to insert or 
retrieve null values will result in a NullPointerException<br>


4. What is String pool in Java and why we need String pool? <br>
The string pool in Java is a special area in memory where strings 
are stored to conserve memory and improve performance. 
It is essentially a cache of string literals created in your 
Java program. When you create a string using double quotes, 
Java checks if an equivalent string already exists in the pool. 
If it does, the new string references the existing one instead 
of creating a new copy. This process is known as interning.
The string pool in Java is a memory optimization technique that 
helps reduce memory consumption and improve string-related 
operations' performance by reusing existing string literals. 
It is an important concept in Java, especially when dealing 
with string-intensive applications.<br>


5. What is Java garbage collection? <br>
Java Garbage Collection is a process by which the Java Virtual Machine
(JVM) automatically manages and reclaims memory that is no longer in
use by the program. It is an essential feature of the Java programming
language that helps developers avoid memory leaks and ensures 
efficient memory utilization. There are some aspect of GC such as:
Automatic Memory Management, Heap Memory,Generation-Based Approach,
GarbageCollection,Triggers,Markand Sweep,Compact,Stop-the-World,Tuning and Customization, and
Finalization.<br>


6. What are accessmodifiers and their scopes in Java? <br>
Access modifiers inJava are keywords used to specify the 
visibility or accessibility of classes,methods, fields, and 
other members within a Java program. They control whichparts 
of a program can access and interact with certain elements and 
helpenforce encapsulation and access control. Java has four main 
access modifierssuch as public private,protected, and default.<br>


7. What is final keyword? (Filed, Method, Class) <br>
In Java, the finalkeyword is used to indicate that something (a variable, a method, or a class)cannot be further modified or extended. It provides a level of immutability orrestricts further inheritance and is often used for various purposes in thelanguage. Final Variable: When applied to a variable (a field), it means thatthe variable's value cannot be changed. The variable must be initializedexactly once either when it is declared or in the constructor of the class. Theconvention is to name final variables in uppercase letters with underscores toindicate they are constants.Final Method: When applied to a method, it meansthat the method cannot be overridden by subclasses. This is often used toenforce that a specific behavior of a method should not be changed bysubclasses.Final Class: When applied to a class, it means that the class cannotbe extended (i.e., it cannot be a superclass for other classes). This is oftenused to prevent further inheritance and to indicate that the class's design iscomplete and should not be extended.<br>


8. What is statickeyword? (Filed, Method, Class). When do we usually use it? <br>
In Java, the statickeyword is used to define elements (fields, methods, and nested classes) thatbelong to the class itself, rather than to instances (objects) of the class.When something is declared as static, it means that there is only one instanceof that element shared across all instances of the class. Static Fields (ClassVariables): Static fields, also known as class variables, belong to the classitself rather than to individual instances of the class. They are shared amongall instances of the class and can be accessed using the class name or aninstance of the class. Common use cases include creating constants, maintainingglobal state, and sharing data across instances.Static Methods: Static methodsbelong to the class and not to any specific instance. They can be called usingthe class name without creating an object. They are often used for utilitymethods, where the method does not depend on the state of individual instancesbut rather performs a general operation related to the class.Static NestedClasses: A static nested class is a class declared within another class, but itis associated with the outer class and not with instances of the outer class.Static nested classes are used when a class is closely related to anotherclass, but it does not need access to the non-static members of the outerclass.<br>


9. What is thedifferences between overriding and overloading? <br>
In Java, Overridingand overloading are two important concepts in object-oriented programming.Overloading refers to defining multiple methods in the same class with the samename but different parameter lists (different types or different numbers ofparameters). The methods are differentiated based on their method signatures.Overriding occurs in a subclass when a method with the same name, return type,and parameters as a method in its superclass is defined. The overriding methodin the subclass provides a specific implementation for the inheritedmethod.overloading is the practice of defining multiple methods with the samename but different parameter lists within the same class, while overriding isthe process of providing a specific implementation for a method inherited froma superclass in a subclass. Overloading is resolved at compile time based onmethod signatures, whereas overriding is resolved at runtime based on theactual object's type.<br>


10. What is thedifferences between super and this?<br>
Super and this are both keywords in Java that are used to refer to different things within a class.super and this are keywords in Javaused to refer to different aspects of a class. super is primarily used forsuperclass members and constructor chaining in the context of inheritance,while this is used for instance members and to differentiate between instancevariables and method parameters within a class.<br>


11. What is the Java load sequence?<br>
In Java, the load sequence refers to the sequence of actions that take place when a class is loaded, initialized, and executed within a Java application. The Java class loading process is a fundamental part of the Java Virtual Machine's (JVM) operation and ensures that classes are properly prepared for execution.The class loading sequence ensures that classes are loaded, prepared, and initialized correctly, following the rules and specifications of the Java language and the JVM, and is a crucial part of the Java runtime environment.<br>


12. What is Polymorphism ?And how Java implements it ? <br>
Polymorphism is afundamental concept in object-oriented programming that allows objects ofdifferent classes to be treated as objects of a common superclass. It enablesyou to write code that can work with objects of various classes in a uniformway, promoting code reusability and flexibility. Polymorphism can be achievedin Java through method overriding and interfaces. Polymorphism simplifies codeby allowing you to write more generic and reusable code that can work with avariety of objects. It is a powerful concept in object-oriented programming andis one of the key principles that promote code flexibility and maintainabilityin Java and other object-oriented languages.<br>


13. What is Encapsulation ?How Java implements it? And why we need encapsulation? <br>
Encapsulation is oneof the four fundamental principles of object-oriented programming (OOP), alongwith inheritance, polymorphism, and abstraction. It refers to the bundling ofdata (attributes or fields) and methods (functions) that operate on that datainto a single unit known as a class. Encapsulation restricts direct access tosome of an object's components, providing control over the object's state andbehavior. It helps in hiding the internal details of an object from the outsideworld while exposing a well-defined interface for interaction.encapsulation isa core principle of OOP that promotes data hiding and controlled access to aclass's members. Java implements encapsulation through access modifiers,private fields, and getter/setter methods, allowing you to protect dataintegrity, provide flexibility, enhance security, and improve codemaintainability and reusability.<br>


14. What is Interface and what is abstract class? What are the differences between them?<br>
Interface and abstract class are two fundamental concepts in object-oriented programming (OOP), used for defining abstractions and providing a blueprint for classes. While they have some similarities, they serve different purposes and have distinct characteristics. An interface defines a contract or a set of abstract methods that must be implemented by any class that claims to implement that interface. It provides a way to achieve multiple inheritance in Java since a class can implement multiple interfaces.Interfaces are used to define contracts, and abstract classes are used to provide a common base with partial implementation for subclasses. The choice between them depends on the specific requirements of your design and whether you need multiple inheritance or a mix of implemented and unimplemented methods.<br>


15. design a parking lot(put the code to codingQuestions/coding1 folder, ) <br>
In coding folder, there are two class and one interface.<br>


16. What are Queue interface implementations and what are the differences and when to use what?<br>
In Java, the Queue interface is part of the Java Collections Framework and represents a linear data structure for storing elements in a specific order. Elements in a queue follow the "first-in, first-out" (FIFO) principle, where the element that was added first is the one that is removed first. The Queue interface is extended by the Deque interface, which adds support for operations at both ends of the queue (front and rear). If you need a simple, single-threaded FIFO queue, you can use LinkedList. If you need a priority queue, use PriorityQueue. If you need a fast, resizable double-ended queue (Deque), use ArrayDeque. For thread-safe operations, use concurrent implementations like ConcurrentLinkedQueue, LinkedBlockingQueue, or PriorityBlockingQueue. If you need blocking behavior for producer-consumer scenarios, consider the blocking Queue and Deque implementations, such as LinkedBlockingQueue and LinkedBlockingDeque.



