1. Explain volatile variables in java? (we also use it in Singleton)<br>
In Java, the volatile keyword is used to declare a variable as volatile. A volatile variable has special characteristics related to visibility and ordering of operations in a multithreaded environment. When a variable is declared as volatile, it ensures the following behavior:Visibility Guarantee, No Caching, Atomicity. In the Singleton pattern, when you want to implement a lazy-initialized, thread-safe Singleton, you can use the volatile keyword to ensure that the Singleton instance is correctly initialized and visible to all threads.By using volatile, we guarantee that the changes made during the creation of the Singleton instance are immediately visible to all threads, and we ensure thread safety without incurring the synchronization overhead every time getInstance is called.<br>


2. How to create a new thread(Please also consider Thread Pool case)?<br> 
In Java, you can create a new thread using the Thread class or by using a thread pool from the java.util.concurrent package. Creating a New Thread using the Thread class. It can create a new thread by extending the Thread class and overriding the run() method, which contains the code to be executed in the new thread. Then, you can create an instance of your custom thread class and start it using the start() method.Using a Thread Pool (Executor Framework):Thread pools provide a more efficient way to manage threads, especially in scenarios where you need to perform multiple tasks concurrently. They reuse a fixed number of threads for multiple tasks, avoiding the overhead of thread creation and destruction for each task. Java's Executor framework provides a convenient way to work with thread pools.<br>

3. Difference between Runnable and Callable<br>
In Java, both Runnable and Callable are interfaces used for defining tasks that can be executed by threads, but they have some key differences in terms of their features and usage. Runnable is a simpler interface for representing tasks without return values, while Callable is a more versatile interface that allows tasks to return values and throw checked exceptions. The choice between them depends on the specific requirements of your task and how you intend to use it with concurrency mechanisms like thread pools.<br>


4. what is the diff between t.start() and t.run()? <br>
t.start() is used to initiate the execution of a new thread and run the run() method concurrently in that new thread.t.run() simply calls the run() method as a regular method call in the current thread, without creating a new thread. In most cases where you want to achieve multithreading or concurrency, you should use t.start() to create a new thread and allow the run() method to execute concurrently. Using t.run() directly as a method call doesn't introduce any multithreading, so it's typically not used for concurrent execution of code.<br>


5. Which way of creating threads is better: Thread class or Runnable interface?<br>
It's recommended to use the Runnable interface because it offers greater flexibility, and better resource management, and promotes cleaner design by separating the thread logic from the rest of your class. You can create instances of your Runnable class and pass them to a Thread or use them with thread pools or other concurrency mechanisms. However, if you have a simple, standalone task that doesn't need to be reused or extended further, extending the Thread class can be a convenient and straightforward choice. Ultimately, the choice between the two approaches depends on the specific requirements and design of your application.<br>


6. What is the thread status?<br>
In Java, threads go through various states during their lifecycle, and these states represent the current status or condition of a thread's execution. The thread states are defined by the Thread. State enumeration and a thread can be in one of these states at any given time. The primary thread states such as NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED. The transitions between these states are managed by the Java Virtual Machine (JVM) and the operating system, and they depend on various factors such as thread scheduling, synchronization, I/O operations, and explicit thread control methods. You can check the state of a thread using the Thread.getState() method, which returns an instance of the Thread. State enumeration. Monitoring thread states is often useful for debugging and understanding the behavior of multithreaded applications.<br>


7. difference between wait() and sleep() method<br>
The key differences between wait() and sleep() are:Purpose: wait() is used for synchronization and inter-thread communication, while sleep() is used for introducing a pause or delay in the execution of a thread. Lock Release: wait() releases the lock on the object it is called on, allowing other threads to acquire the lock and execute synchronized code. sleep() does not release any locks.Waking Up: Threads calling wait() are awakened by other threads using notify() or notifyAll(). Threads calling sleep() automatically wake up when the specified sleep duration elapses or when they are interrupted. The choice between wait() and sleep() depends on the specific requirements of your program. Use wait() for synchronization and communication between threads, and use sleep() for introducing delays or implementing periodic tasks.<br>


8. What is deadlock? <br>
Deadlock is a situation in concurrent programming where two or more threads or processes are unable to proceed with their execution because they are each waiting for the other(s) to release a resource or terminate. In a deadlock, the threads or processes become stuck indefinitely, and the application cannot make any further progress.Preventing and handling deadlocks is an essential aspect of concurrent programming to ensure the reliability and stability of multi-threaded or multi-process applications.<br>


9. How do threads communicate with each other? <br>
Threads can communicate with each other in a multi-threaded program through various mechanisms and synchronization techniques to exchange data, coordinate their activities, and avoid conflicts. Here are some common ways threads communicate such as: Shared Variables, Inter-Thread Signaling, Blocking Queues, Thread Pools, Semaphore and CountDownLatch, Message Passing.<br>


10. What is join() method? <br>
The join() method in Java is a synchronization method provided by the Thread class that allows one thread to wait for the completion of another thread before proceeding. When a thread calls the join() method on another thread, it essentially waits until that other thread finishes its execution or until a specified timeout period elapses.The join() method is a useful mechanism for coordinating the execution of threads in scenarios where one thread depends on the results or completion of another thread.<br>


11. what is yield() method<br>
The yield() method is a static method in Java that is used to suggest to the Java Virtual Machine (JVM) that the current thread is willing to yield its current processor time to other threads. It's a hint to the scheduler that the current thread is not performing a critical task and is willing to give other threads a chance to run.It's important to note that the behavior of yield() can vary depending on the JVM and the underlying operating system. The scheduler may or may not honor the yield request, and there are no guarantees about which thread will run next. Therefore, yield() is typically used in situations where it's not critical which thread gets to execute next, and it should not be used as a means of synchronization or critical thread control.<br>


12. Explain thread pool<br>
A thread pool is a managed pool of worker threads that are used to efficiently execute tasks concurrently in a multithreaded application. The primary goal of a thread pool is to control and limit the number of threads that are active or available for executing tasks, which helps manage system resources and improves application performance. Thread pools are a common and essential component in concurrent programming.Thread pools are an essential tool for managing concurrent tasks in multithreaded applications, and they help improve efficiency and resource utilization while simplifying thread management.<br>


13. What is Executor Framework in Java, its different types and how to create these executors?<br>
The Executor Framework in Java is a higher-level concurrency framework introduced in Java 5 (Java SE 5.0) that simplifies the management and execution of concurrent tasks by providing a standardized way to create, manage, and control threads for executing tasks. It abstracts away many low-level details of thread management and offers a more convenient and efficient way to work with threads and tasks.Executor Framework include: Executor Interface, ExecutorService Interface, ThreadPoolExecutor, Executors Utility Class. The Executor Framework simplifies concurrent programming by providing a high-level abstraction for managing and controlling the execution of tasks with thread pools. It helps improve code readability and maintainability and offers better resource management compared to managing threads manually.


14. Difference between shutdown() and shutdownNow() methods of executor<br>
In the Java Executor Framework, both shutdown() and shutdownNow() methods are used to shut down an ExecutorService.Use shutdown() when you want to allow the already submitted tasks to complete their execution before shutting down the ExecutorService gracefully. It is suitable for scenarios where you want to finish pending work.Use shutdownNow() when you want to forcefully stop the ExecutorService and do not need to wait for the tasks to complete. Be aware that some tasks may not be interrupted and may continue running.It's important to handle the returned list of tasks from shutdownNow() if you need to perform any cleanup or analysis on the tasks that were in the queue when the shutdown was initiated. Additionally, always check the isShutdown() and isTerminated() methods to determine the state of the ExecutorService after calling shutdown() or shutdownNow().<br>


15. What is Atomic classes? when do we use it? <br>
Atomic classes in Java, found in the java.util.concurrent.atomic package, are a set of classes that provide atomic operations on primitive data types and reference variables. These classes are designed for multithreaded applications and ensure that certain operations are executed atomically, without the need for explicit synchronization using locks or the synchronized keyword.The primary use case for atomic classes is to provide thread-safe, non-blocking, and efficient access to shared variables. They are commonly used in scenarios where multiple threads need to read and update a variable simultaneously, and you want to avoid race conditions and ensure data consistency without using locks.<br>


16. What is the cocurrent collections? <br>
Concurrent collections, also known as concurrent data structures, are a set of thread-safe data structures provided by the Java Concurrency Framework (in the java.util.concurrent package) to support concurrent access and modification by multiple threads without the need for explicit synchronization using locks. These collections are designed for high concurrency and are essential in building efficient and scalable multithreaded applications.ConcurrentHashMap, ConcurrentSkipListMap, ConcurrentSkipListSet, ConcurrentLinkedQueue, ConcurrentLinkedDeque, CopyOnWriteArrayList, CopyOnWriteArraySet, BlockingQueue, ConcurrentBag ConcurrentHashMap.KeySetView, ConcurrentHashMap.ValuesView, ConcurrentNavigableMap, ConcurrentNavigableSet<br>


17. What kind of locks you know? <br>
There are several types of locks and synchronization mechanisms used for managing concurrent access to shared resources. These locks and synchronization mechanisms are essential for ensuring thread safety and preventing race conditions in multithreaded applications.ReentrantLock, ReadWriteLock, StampedLock, Lock.<br>


18. What is the difference between class lock and object lock?<br>
Class locks are associated with classes and are used for synchronizing access to static members of a class. Object locks are associated with instances (objects) of a class and are used for synchronizing access to instance-specific members of a class. Multiple threads can hold object locks for different instances concurrently, while only one thread can hold the class lock for a class at a time. The choice between using class locks or object locks depends on the specific requirements of your application. Class locks are suitable for synchronizing access to shared static resources, while object locks are used to synchronize access to instance-specific data within objects.<br>


19. What is future and completableFuture?<br>
CompletableFuture provides a more versatile and expressive way to work with asynchronous tasks and supports more complex scenarios than the basic Future interface. It is widely used in modern Java applications for handling asynchronous and concurrent programming tasks.<br>


20. what is ThreadLocal? <br>
ThreadLocal is a class in Java that provides thread-local variables. A thread-local variable is a variable that has its own separate copy for each thread that accesses it. In other words, each thread that uses a ThreadLocal variable has its own isolated instance of that variable, and changes made to the variable by one thread do not affect the values seen by other threads.ThreadLocal can be a powerful tool for managing per-thread state and avoiding synchronization overhead in multithreaded applications. However, it should be used judiciously, as excessive use of thread-local variables can lead to increased memory consumption and complexity in your code.<br>

21. This question in the code folder.
22. This question in the code folder.
23. This question in the code folder.
24. This question in the code folder.
25. This question in the code folder.