**********************************
Q1. List all of annotations you learned from class and homework to annotations.md

See annotations.md
**********************************
Q2. What is Spring and Spring Boot? What is the benefits of using Spring Boot?

`Spring` : Spring is a widely used open-source framework for building Java-based enterprise applications. 
It provides comprehensive support for various aspects of application development, 
including dependency injection, AOP (Aspect-Oriented Programming), and more.

`SpringBoot`: Spring Boot is an extension of the Spring framework that simplifies and accelerates the process of building production-ready applications. 
It provides a set of conventions and tools for quickly creating stand-alone, production-grade Spring-based applications with minimal configuration, making it easier to get started with Spring development.

`Benefits of using Spring Boot`: Spring Boot simplifies and accelerates Java application development by providing built-in configurations, 
easy setup, and production-ready features, reducing development time and complexity.
**********************************
Q3. What is IOC? What is DI? 

`IOC`: IOC (Inversion of Control) is a design principle in which the control over the flow of a program's execution is shifted from the program itself to an external framework or container.

`DI`:  DI (Dependency Injection) is a specific implementation of IOC, where a component's dependencies are provided or "injected" into it, 
rather than the component creating or managing its dependencies. 
This promotes loose coupling and makes code more maintainable and testable.
**********************************
Q4. What is @ComponentScan?

Define where the spring need to scan the bean definitions and generate the beans. 

@ComponentScan is an annotation in the Spring Framework used to specify the base packages to scan for Spring-managed components, 
such as beans annotated with @Component, @Service, @Repository, and @Controller. 
It allows Spring to discover and register these components, making them available for dependency injection and other Spring features.
By configuring @ComponentScan, you can control which packages Spring should search for components, helping to organize and manage your application's beans.
**********************************
Q5. How to define which package spring need to scan in xml and annotation?

XML: `<context:component-scan base-package="com.example.app.components" />`
> This XML configuration tells Spring to scan the "com.example.app.components" package and its sub-packages for components annotated with @Component, @Service, @Repository, and @Controller.

Annotation: `@ComponentScan(basePackages = "com.example.app.components")`
> You can use the @ComponentScan annotation on a configuration class to specify the base packages to scan.
**********************************
Q6. What is  @SpringbootApplication? 

It is used to mark the main class of a Spring Boot application. This annotation combines three commonly used annotations in a Spring Boot application:

1. @Configuration: Declares a class as the source for bean definitions. 
2. @EnableAutoConfiguration: allows the application to add beans using classpath definitions. 
3. @ComponentScan: directs Spring to search for components in the path specified. 
**********************************
Q7. How many ways we can define a bean?

1. @Component
2. @ControllerAdvice
3. @Bean
4. @Configuration
5. @Service
6. @Repository
7. @Controller
8. @RestController
9. XML
**********************************
Q8. What is default bean name for  @Component and  @Bean?

Derived from the name of the annotated class or method, respectively. 
**********************************
Q9. What is the difference between  @component and  @service,@repository?

1. @Component is a generic stereotype for any Spring-managed component.
2. @Service is specifically used for service layer components.
3. @Repository is specifically used for data access components.

The difference between them is only the purpose of the component. 
**********************************
Q10. How many annotations we can use to inject the bean?

@Autowired: Used to automatically inject a bean by type. It's a versatile and widely used annotation for dependency injection.

@Qualifier: Used in conjunction with @Autowired to specify the bean name when multiple beans of the same type are available.

@Resource: Similar to @Autowired, but it allows specifying the bean name or qualifier directly.

@Value: Used to inject values from property files or environment variables into bean properties.

@Inject: Similar to @Autowired, typically used in Java EE and CDI contexts.

@Lazy: Used to specify that a bean should be lazily initialized when it's first accessed.

@Required: Used to indicate that a bean property must be set.

@Primary: Used to indicate that a specific bean should be given priority when multiple candidates of the same type are available.

Priority order: @Resource > @Qualifier > @Primary > @Autowired > @Inject > @Value > @Lazy > @Required
**********************************
Q11. Tell me the three types to do dependency injection(How can we inject the beans
in Spring)? Which way is better and why?

1. Constructor injection: The dependencies are provided as constructor parameters.
2. Setter injection: The dependencies are assigned using setter methods.
3. Field injection: The dependencies are assigned directly to class fields.

Constructor injection is the preferred method for dependency injection in Spring: Better Testing, Immutability, and Thread Safety.
**********************************
Q12. If we have multiple beans for one type, how to set one is primary? and how to let
the spring pick one bean to inject if no primary. 

@Primary: Used to indicate that a specific bean should be given priority when multiple candidates of the same type are available.
If no primary, you can control the selection of the bean to inject using the @Qualifier annotation.
**********************************
Q13. What is the difference between BeanFactory and ApplicationContext in Spring?

BeanFactory: Bean instantiation
ApplicationContext: Bean instantiation + Bean lifecycle management + AOP features
**********************************
Q14. What is the Scope of a Bean?  and list the examples for each scope.

Bean scope in Spring determines the lifecycle and visibility of a bean. Common scopes include:
1. Singleton (default): A single instance for the whole application.
2. Prototype: A new instance each time it's requested.
3. Request (web): For each HTTP request.
4. Session (web): For each user's session.
5. Application (web): A single instance for the web application.
6. WebSocket (web): For each WebSocket session.
**********************************
Q15. Configure a bean using xml. If bean has parameters/dependencies, how can we
configure the bean? (you can google the tutorial how to configure beans in xml,
and feel free to ask me any questions if you don't understand. it is a little bit old,
I am not sure if I need to explain it in class)

Class: 

            public class MyBean {
            private String message;
        
            public MyBean(String message) {
                this.message = message;
            }
        
            public void displayMessage() {
                System.out.println(message);
            }

XML: 

            <?xml version="1.0" encoding="UTF-8"?>
            <beans xmlns="http://www.springframework.org/schema/beans"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                xsi:schemaLocation="http://www.springframework.org/schema/beans
                    http://www.springframework.org/schema/beans/spring-beans.xsd">

                <!-- Define the MyBean bean with constructor arguments -->
                <bean id="myBean" class="com.example.MyBean">
                    <constructor-arg value="Hello, Spring!" />
                </bean>
            </beans>


Application: 

            import org.springframework.context.ApplicationContext;
            import org.springframework.context.support.ClassPathXmlApplicationContext;
            
            public class Main {
                public static void main(String[] args) {
                    ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

                    MyBean myBean = (MyBean) context.getBean("myBean");
                    myBean.displayMessage();
                }
            }
**********************************
