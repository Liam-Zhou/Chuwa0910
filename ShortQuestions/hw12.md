# hw11- Ke Chen - Spring Basic

## 1.  List all of the annotations you learned from class and homework to annotaitons.md

**find in ShortQuestions file: annotations.md**




## 2.  What is Spring and Springboot? What is the benfits of using Srpingboot?

**What is Spring:**

Spring is <u>a lightweight, loosely coupled and integrated framework to build applications.</u>

**What is Springboot:**

Spring Boot is <u>a framwork provides RAD (Rapid Application Development) feature to Spring framework to Spring</u>.


**the benfits of using Srpingboot?**

1. Simplified Configuration: 
    - providing default configurations for various Spring modules, reducing the need for manual setup and configuration.

2. Rapid Development
    - priving starter dependencies, can also reducing the need for manual setup and configuration.

3. embedded servers:
    - Spring Boot embeds servlet containers like Tomcat, reducing the need for deploying WAE/JAR file(run the application as a standalone JAR file).




## 3.  What is IOC and What is DI?

<u>IOC is stand for Inversion of Control: instead create object by using new keyword, but give the control to an external entity, like Spring</u>

<u>DI is stand for Dependency Injection to inject dependencies into a class rather than letting the class create them itself.</u>

IOC container is responsible to:
- create the instance
- configure the instance
- assemble the dependencies




## 4.  What is  @CompnonentScan?
@ComponentScan is an annotation that is used to <u>specify the base packages to scan components</u>.

在哪个包下寻找@Component注解标记的组件类，以便自动注册它们到应用程序的上下文中




## 5.  How to define which package spring need to scan in xml and annotaiton? 

**by using @ComponentScan:**

<u>for @ComponentScan, use the basePackeges value to define which package and all it's subpackage need to scan.</u>

```java
@Configuration
@ComponentScan(basePackages = "com.example.myapp")
public class AppConfig {
    // Define other beans and configuration here
}
```

**By using XML configuration:**

<u>for XML, use the <context:component-scan> element in XML configuration file (applicationContext.xml).</u>

```conf
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
          http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

    <context:component-scan base-package="com.example.myapp" />
    
    <!-- Define other beans and configuration here -->

</beans>
```




## 6.  What is @SpringbootApplication?

@SpringBootApplication is <u>a combination of `@Configuration`, `@EnableAutoConfiguration` and `@ComponentScan`</u>

Its primary role is to <u>mark the entry point of the application and enable auto-configuration and define the base package to scan component.</u>

- `@Configuration`: marks a class as a source of bean definitions to define Spring beans using @Bean annotations within the class.
- `@EnableAutoConfiguration`: allows the application to add beans using classpath definitions.
- `@ComponentScan`: specify the base packages to scan components.

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MySpringBootApplication {

    public static void main(String[] args) {
        SpringApplication.run(MySpringBootApplication.class, args);
    }
}
```




## 7. How many ways wo can define a bean?

- class level:
    - @Component
    - @Service
    - @Repository
    - @Controller
    - @ControllerAdvice
- Method level
    - @Bean(used with @Configuration) together
- XML
    - by tag <bean></bean>




## 8.  What is default bean name for @Component and  @Bean?

**For @Component:**

the default bean name for a class annotated with @Component is generated <u>based on the class name, but with the first letter in lowercase</u>

For example, if the class named MyComponent, the default bean name would be myComponent.

```java
@Component
public class MyComponent {
    // ...
}
```

**For @Bean:**

the default bean name <u>is based on the method name, and also with the first letter in lowercase</u> used to define the bean. 

For example, if you have a method named myBean that is annotated with @Bean, the default bean name would be myBean.

```java
@Configuration
public class AppConfig {
    @Bean
    public MyBean myBean() {
        return new MyBean();
    }
}
```




## 9.  What is the difference between @component and @Controller, @service, @repository?

<u>@Component is the most generic sterotype annotation to indicate a class is a component.</u>

It's often used for generic, non-specialized components.

<u>@Controller, @service, @repository are specialization of `@Component`.</u>




## 10. How many annotaitons we can use to inject the bean?

1. @Autowired: inject beans by type
2. @qualifier: work with `@Autowired` to provide the name of bean to inject when there are multiple beans with same type.
3. @primary: to indicate this bean is the primary bean for autowiring when there are multiple beans with same type and not define @Qualifier
4. @Resource: inject beans by name by using the value of name
5. @Inject: similar to `@Autowired` and can be used for bean injection by type.

Priority: By Type > @Qualifier > @Primary > By Name > throw exception(NoUniqueBeanDefinitionException)

![annotation to inject the bean](../images/hw12/annotation%20to%20inject%20the%20bean.png)




## 11. Tell me the three types to do dependency injection(How can we inject the beans in Spring)? Which way is better and why?

**three types to do dependency injection:**

1. constructor injection: dependency passed as arguments to the constructor
2. Setter Injection: create setter method for the dependency, allowing external classes or frameworks to set these dependencies.
3. Field Injection: Dependencies are directly injected into class fields using annotations such as @Autowired

```java
// by constructor
public class MyClass {
    private final Dependency dependency;

    public MyClass(Dependency dependency) {
        this.dependency = dependency;
    }
}

// by setter
public class MyClass {
    private Dependency dependency;

    public void setDependency(Dependency dependency) {
        this.dependency = dependency;
    }
}

// by field
public class MyClass {
    @Autowired
    private Dependency dependency;
}
```

**Which way is better and why?**

**constructor injection is better.** 

It <u>ensures that all dependencies is fully initialized when the object created</u>. It helps in achieving better immutability, easier testing, and clearer dependencies.  在object创建的时候同时也把dependency注入进入了。

**Setter Injection** allows for flexibility as dependencies can be changed after the object is created. However, it <u>doesn't guarantee that a bean is fully initialized when object created.</u>  对象在创建后没有立即处于完全初始化状态。

**Field Injection** is convenient but can <u>make code less testable and harder to maintain.</u> 降低代码的可测试性并很难去管理。




## 12. If we have multiple beans for one type, how to set one is primary? and how to let the spring to pick one bean to inject if no primay.

<u>by using the annotation: `Primary` to indicate this bean is the primary bean for autowiring when there are multiple beans with same type and not define @Qualifier.</u>

```java
@Component
@Primary
public class PrimaryBean implements MyBean {
    // ...
}
```

<u>Priority: By Type > @Qualifier > @Primary > By Name > throw exception(NoUniqueBeanDefinitionException)</u>

1. @Autowired: inject beans by type
2. @qualifier: work with `@Autowired` to provide the name of bean to inject when there are multiple beans with same type.
3. @primary: to indicate this bean is the primary bean for autowiring when there are multiple beans with same type and not define @Qualifier
4. @Resource: inject beans by name by using the value of name
5. @Inject: similar to `@Autowired` and can be used for bean injection by type.




## 13. What is the difference between BeanFactory and ApplicationContext in Spring?

1. basic
- BeanFactory provides the basic configuration support and bean instantiation, 
- ApplicationContext is an extension of BeanFactory with additional functionalities like event propagation, internationalization, and application layer-specific context.

2. Loading
- BeanFactory loads beans lazily by default, i.e., the beans are initialized only when requested. 
- ApplicationContext pre-instantiates all singleton beans during the container startup.


- 1.BeanFactory是Spring的早期接口，称为Spring的Bean工厂，ApplicationContext是后期更高级接口，称之为Spring 容器。
- 2.ApplicationContext在BeanFactory基础上对功能进行了扩展，例如：监听功能、国际化功能等。BeanFactory的API更偏向底层，ApplicationContext的API大多数是对这些底层API的封装。
- 3.Bean创建的主要逻辑和功能都被封装在BeanFactory中，ApplicationContext不仅继承了BeanFactory，而且ApplicationContext 内部维护了 BeanFactory： 既有继承关系，也有内部融合关系.
- 4.Bean的初始化时机不同，原始BeanFactory是在首次调用getBean时才进行Bean的创建，而ApplicationContext则是配置文件加载，容器一创建就将Bean都实例化并初始化好。




## 14. What is the Scope of a Bean?  and list the examples for each scope.

**What is the Scope of a Bean?**

a bean's scope <u>determines how long the bean instance will be available and how it will be shared among multiple clients.</u>

**list the examples for each scope:**

- `singleton`: 
    - the bean instance will created be only once and same instance will be returned by the IOC container
    - by using @Scope("singleton")
    - Configuration classes, utility classes, stateless services.

- `prototype`: 
    - the bean instance will be created each time when requested.
    - by using @Scope("prototype")
    - Objects that need to be uniquely instantiated each time, such as user sessions, shopping cart items.

- `request`: 
    - the bean instance will be created per HTTP request
    - by using @RequestScope
    - Web controllers, objects that need to be available during a single HTTP request.
    - Objects that need to be created anew for each HTTP request, like request-specific data processing, form handling objects.

- `session`: 
    - the bean instance will be created per HTTP session
    - by using @SessionScope
    - User-specific information stored across multiple requests, session-related data.

- `global-session(Portlet context)`:  
    - the bean instance will be created per HTTP global session. It can be used in portlet context only.
    - by using @Scope("globalSession")
    - Portlet-specific objects that need to be maintained across requests within a global session.

```java
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

// Singleton Scope
@Component
@Scope("singleton")
public class SingletonBean {
    // Implementation...
}

// Prototype Scope
@Component
@Scope("prototype")
public class PrototypeBean {
    // Implementation...
}

// Request Scope (for web applications)
import org.springframework.web.context.annotation.RequestScope;
import org.springframework.stereotype.Component;

@Component
@RequestScope
public class RequestScopedBean {
    // Implementation...
}

// Session Scope (for web applications)
import org.springframework.web.context.annotation.SessionScope;
import org.springframework.stereotype.Component;

@Component
@SessionScope
public class SessionScopedBean {
    // Implementation...
}


// global-seesion Scope
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

@Component
@Scope("globalSession")
public class MyGlobalSessionBean {
    // Implementation...
}
```


## 15. Configure a bean using xml. If bean has parameters/dependencies, how can we configure the bean? 

you can google the tutorial how to configure beans in xml, and feel free to ask me any quesitons if you don't understand. it is a little bit old, I am not sure if I need to exaplain it in class

In Spring XML configuration, we can define beans and configure them, including specifying their dependencies, by using the <bean> element and related attributes.

1. **Define the Bean in XML**: 

    First, define the bean using the `<bean>` element. We need to specify the following attributes:

    - `id` or `name`: The unique identifier for the bean.
    - `class`: The fully-qualified class name of the bean.
        
    For example:

    ```xml
    <bean id="myBean" class="com.example.MyBean">
        <!-- Bean configuration goes here -->
    </bean>
    ```

2. **Configure Dependencies**: 

    To configure dependencies or set properties for the bean, we can use child elements within the <bean> element. 

    There are various elements can use for different types of dependencies or properties:

    - `<property>`: Used to set properties on the bean. It's particularly useful for setting simple values.
    - `<ref>`: Used to reference other beans and inject them as dependencies.
    - `<list>`, `<set>`, `<map>`, and `<props>`: Used for configuring collections and maps.
   
   Here's an example of configuring a dependency using `<property>`:

    ```xml
    <bean id="myBean" class="com.example.MyBean">
        <property name="myProperty" value="someValue" />
    </bean>
    ```

    We can use `<ref>` to inject other beans as dependencies:

    ```xml
    <bean id="myBean" class="com.example.MyBean">
        <property name="myDependency">
            <ref bean="anotherBean" />
        </property>
    </bean>
    ```

3. **Injecting Values from Properties Files**: 

    If we want to inject values from external properties files, we can use placeholders. We typically use the `property-placeholder` element to configure the location of the properties file.

    ```xml
    <bean id="myBean" class="com.example.MyBean">
        <property name="myProperty" value="${some.property}" />
    </bean>

    <context:property-placeholder location="classpath:my-properties-file.properties" />
    ```

4. **Importing Additional XML Configuration Files**: 

    If configuration becomes too large, we can split it into multiple XML files and import them into main configuration file using the `<import>` element.

    ```xml
    <import resource="classpath:additional-configuration.xml" />
    ```

5. **Define Additional Beans**: 

    We can define more beans by creating additional `<bean>` elements within XML configuration file, and we can reference or inject these beans as dependencies in other beans.