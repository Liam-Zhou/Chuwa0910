# hw12 - Ke Chen - Spring Security

## 1.  List all of the annotations you learned from class and homework to annotaitons.md
see file: annotaitons.md - spring security部分

## 2.  What is the authentication? 验证
In the Spring Framework, authentication is <u>the process of verifying the identity of a user or entity, ensuring that the user is who they claim to be</U>. 

Here's a simple example of a Spring Security authentication configuration using Java-based configuration:

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private UserDetailsService userDetailsService;

    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
    }

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
                .and()
            .formLogin()
                .loginPage("/login")
                .permitAll()
                .and()
            .logout()
                .permitAll();
    }
}
```
This configuration sets up form-based authentication and specifies which URLs are accessible without authentication and which require authentication.


## 3.  What is the authorization? 授权，确定是否有资格
Authorization in Spring refers to <u>the process of determines what an authenticated user is allowed to do within the application.</u>. It defines the user's permissions, rights, and access control rules.

Here's a simple example of method-level security using `@PreAuthorize`:
　
```java
@PreAuthorize("hasRole('ROLE_ADMIN') or hasRole('ROLE_MANAGER')")
public void adminOrManagerMethod() {
    // This method can be accessed by users with ROLE_ADMIN or ROLE_MANAGER.
}
```


## 4.  What is the difference between authentication and authorization?
**Authentication** is <u>the process of verifying the identity of a user or entity, ensuring that the user is who they claim to be</U>. 

**Authorization** in Spring refers to <u>the process of determines what an authenticated user is allowed to do within the application.</u>. It defines the user's permissions, rights, and access control rules.

## 5.  What is HTTP Session?
An HTTP session is <u>a mechanism</u> used to <u>maintain state and store information about a user's interactions with a web application</u> over a series of HTTP requests and responses.  保留state并且储存关于用户和web application交互的信息

HTTP itself is a stateless protocol, meaning that each request from a client to a server is independent and doesn't inherently retain any information about previous requests. To overcome this statelessness and provide a way to store user-specific data between requests, HTTP sessions were introduced.


## 6.  What is Cookie? 
A cookie is <u>a small piece of data that a web server sends to a user's web browser</u>. 
The browser stores this data and includes it with every subsequent request to the same server. 

Cookies are commonly used to maintain state, store user preferences, and track user behavior across different pages or sessions in web applications. They are a fundamental component of web technology and play a crucial role in enhancing the user experience on the web.

Cookies are an essential part of web development and enable web applications to provide personalized and interactive experiences for users. They help maintain state across different pages and sessions, store user data, and improve the efficiency and user-friendliness of websites. However, developers and website operators should handle cookies responsibly and ensure they comply with relevant privacy regulations to protect user data and privacy.

## 7. What is the difference between Session and Cookie?

Here are the key differences between sessions and cookies:

1. **Purpose**:
   - **Session**: Sessions are used to <u>maintain state and store user-specific data</u> on the server between HTTP requests. They enable the server to remember information about a user's interactions with a web application during a session. 储存state + data
   - **Cookie**: Cookies are used to <u>store small pieces of data</u> on the user's device (typically in the browser) and send that data back to the server with each HTTP request. They are often used for user identification, personalization, and tracking. 只储存一部分data， 并且会send that data back。

2. **Storage Location**:
   - **Session**: Session data is stored <u>on the server</u>. The server associates a session ID with each user, and the data is kept on the server's memory or in a database. 储存在server端
   - **Cookie**: Cookies are stored <u>on the user's device (browser)</u> 储存在客户端. Each cookie is associated with a specific domain and path and is sent by the browser to the server with each request.

3. **Scope**:
   - **Session**: Session data is typically available for the duration of a user's session. It expires when the session ends (e.g., when the user logs out or the session times out).
   - **Cookie**: Cookies can have different lifetimes. Some are session cookies, which are stored only for the duration of the user's session, while others are persistent cookies, which remain on the user's device for a specified period, even after the session ends.

4. **Security and Privacy**:
   - **Session**: Session data is generally more secure than cookies because it is stored on the server. However, session management should be implemented securely to prevent attacks like session hijacking.
   - **Cookie**: Cookies are susceptible to security issues, such as cross-site scripting (XSS) and cross-site request forgery (CSRF) attacks. Developers should implement security best practices to protect sensitive data stored in cookies.


## 8.  How do we use session and cookie to keep user information across the the application? 

The process of using sessions and cookies for client-server interaction involves several steps:

**Using Sessions and Cookies for Client-Server Interaction:**

1. **Client Sends Request to Server**:
   - The client (typically a web browser) sends an HTTP request to the server to access a web page or resource.

2. **Server Creates Session**:
   - Upon receiving the request, <u>the server may create a new session for the client. It generates a unique session ID to identify the session and stores it on the server</u>.  
   
   产生新session，并且产生一个session ID 储存在server端

3. **Server Sends Response with Cookie**:
   - As part of the HTTP response, <u>the server may include a "Set-Cookie" header in the response. This header contains the session ID as a cookie and is sent back to the client. The cookie is stored in the client's browser</u>.  
   
   server端将会在response包含一个set-cookie的header。这个header返回一个cookie（包含session ID）给客户端。客户端将cookie存储。

4. **Client Stores Cookie**:
   - <u>The client's browser stores the received cookie, associating it with the server's domain and path. This allows the browser to send the cookie with subsequent requests to the same domain and path</u>.  
   
   同时这个cookie也包含server端的domain和path，以便下次对同一个server端发起的请求

5. **Client Sends Cookie with Subsequent Requests**:
   - <u>For all subsequent requests to the same server (within the domain and path specified in the cookie), the client's browser automatically includes the stored cookie in the request headers</u>.

   对于接下来同一个server端发起的请求，客户端自动包含了储存的cookie

6. **Server Retrieves Session Data**:
   - <u>When the server receives a request with the session ID (via the cookie), it uses this ID to look up the corresponding session data stored on the server</u>. This data may include user-specific information, session state, and other relevant details.

   当server端收到了来自带有session id的请求，他用这个id来查看相应储存在server端的session信息

7. **Server Processes Request**:
   - The server processes the request, using the session data to provide a personalized experience, maintain state, or implement access control based on the user's session.

8. **Client Receives Response**:
   - The server sends an HTTP response back to the client, which may include new or updated cookies if necessary.

9. **Session Maintenance**:
   - The client and server continue this process, with the client including the session cookie in each subsequent request. The server maintains the session, and the session data is updated as needed during the user's interaction with the application.

10. **Session Expiry and Cleanup**:
   - Sessions have a defined lifetime or timeout period. When the session expires due to inactivity or other factors, the server may automatically clean up the session data. The client's browser will still retain the cookie, but it will no longer be associated with a valid session on the server.


## 9.  What is JWT?

JWT, which <u>stands for "JSON Web Token"</u>, is a compact, self-contained, and widely used method <u>for securely transmitting information between parties as a JSON object</u>.  一个方法： 用JSON object的形式来进行信息的传输

JWTs <u>are often used for authentication and authorization</u> in web applications and APIs, and they provide a way to encode information in a verifiable and tamper-resistant manner. 经常用做authentication and authorization，并且他们提供了一个encode infomation的方式

Here are some key characteristics of JWTs:

1. **Compact Format**: JWTs are designed to be compact and <u>can be easily transmitted as URL parameters, in an HTTP header, or within an HTTP cookie</u>. 

2. **Self-Contained**: A JWT is self-contained and contains all the information needed to verify its authenticity. This means that <u>the necessary data is included within the token itself</u>.

3. **JSON-Based**: JWTs <u>are represented as JSON objects</u>, making them easy to work with in various programming languages.

4. **Three Parts**: A JWT typically <u>consists of three parts: a header, a payload, and a signature</u>. These parts are encoded and concatenated using a delimiter (usually a period) to form the complete JWT.

   - **Header**: The header typically specifies the type of token (JWT) and the signing algorithm being used.
   - **Payload**: The payload contains claims, which are statements about an entity (typically, the user) and additional data. Claims are categorized as registered, public, or private, depending on their intended use.
   - **Signature**: The signature is used to verify the authenticity of the token. It is generated by signing the encoded header and payload with a secret key or a private key.

5. **Stateless**: <u>JWTs are stateless</u>, meaning that each JWT is independent, and the server does not need to store information about the token or the user's session. This makes JWTs suitable for scaling web applications.


## 10. What is the spring security filter?

In Spring Security, filters play a fundamental role in securing web applications. Spring Security uses a chain of filters <u>to intercept and process HTTP requests and responses</u>, <u>applying various security measures, such as authentication and authorization checks</u>. These filters collectively form the Spring Security Filter Chain.

**The Spring Security Filter Chain** is <u>a sequence of filters that execute in a specific order to enforce security policies on incoming HTTP requests</u>.  注意order顺序。 Each filter in the chain performs a specific security-related task. These filters can be customized and configured to meet the requirements of your application. 

The order of these filters is crucial, as they are executed in sequence when an HTTP request is processed. The order ensures that authentication, authorization, and other security checks happen in a coordinated manner.

Here are some commonly used Spring Security filters:

1. **SecurityContextPersistenceFilter**: This filter ensures that the `SecurityContext` is available to subsequent filters. It loads the user's security context from a session or other storage and associates it with the current request.

2. **UsernamePasswordAuthenticationFilter**: This filter is responsible for handling login requests, typically through a form-based authentication mechanism. It processes login form submissions, authenticates users, and establishes a user's security context.

3. **BasicAuthenticationFilter**: If your application uses HTTP Basic Authentication, this filter handles authentication by decoding credentials from the request's `Authorization` header.

4. **RememberMeAuthenticationFilter**: This filter manages "remember me" authentication, allowing users to be remembered between sessions even after they log out.

5. **AnonymousAuthenticationFilter**: This filter provides a default `Authentication` object (usually representing an anonymous user) for unauthenticated requests. It ensures that there is always a valid `Authentication` object for every request.

6. **SessionManagementFilter**: This filter manages user sessions, handling features like concurrent session control and session fixation protection.

7. **ExceptionTranslationFilter**: This filter is responsible for handling security exceptions and translating them into appropriate HTTP responses. For example, it can handle authentication failures and redirect users to a login page.

8. **FilterSecurityInterceptor**: This filter enforces access control decisions based on the configuration provided by the developer. It checks if a user has the required authorities or roles to access a resource.

9. **CsrfFilter**: This filter provides protection against Cross-Site Request Forgery (CSRF) attacks by validating the presence of a CSRF token in POST requests.

10. **LogoutFilter**: This filter handles the process of logging users out, including invalidating the session and performing additional logout-related tasks.

11. **RequestCacheAwareFilter**: This filter stores the original request and its associated exception (if any) so that it can be reattempted after a successful login.

12. **Custom Filters**: Developers can also create custom filters to handle specific security tasks or integrate with third-party authentication mechanisms.


## 11. decribe how do JWT work(slides 里有图: how do JWT work)

1. the client do a user autehnticates by providing username and password
2. the server validate the username and password and generate the JWT using secret key.(including header, payload and signature)
3. the server return the generated JWT to client
4. the client stores the token and includes it in subsequent HTTP requests
5. the server validate JWT using secret key
6. the server return the response

### details: 

1 + 2. **Token Creation**:

   The process begins when a user authenticates with a system, typically by providing a username and password.

   Upon successful authentication, the system creates a JWT, which consists of three parts: the header, payload, and signature.

   - Header:
   The header typically specifies the type of token (JWT) and the signing algorithm being used. The header is JSON-encoded and included in the token.

   - Payload:
   The payload contains claims, which are statements about an entity (e.g., the user) and additional data. Claims can be categorized as follows:
     - **Registered Claims**: These are predefined claims that have specific meanings, such as "iss" (issuer), "sub" (subject), "exp" (expiration time), and "iat" (issued at).
     - **Public Claims**: These are custom claims that can be defined by the application.
     - **Private Claims**: These are custom claims that are specific to the parties involved in the token exchange.
     The payload is also JSON-encoded and included in the token.

   - Signature:
   The signature is generated by signing the encoded header and payload with a secret key or a private key. The signature ensures the token's authenticity and integrity. Only parties with access to the secret key or the public key can verify the signature.

3. **Token Transmission**:
   - Once the JWT is created, it can be transmitted to the client or another party. Common methods of transmission include as a URL parameter, within an HTTP header, or within an HTTP cookie.

4. **Token Usage**:
   The recipient of the JWT (e.g., a client or a server) stores the token and includes it in subsequent HTTP requests.

5. **Token Verification**:
   When the JWT is presented, the recipient uses the token's header and payload to verify its authenticity and integrity.
   The recipient also checks the token's expiration time and other claims to ensure the token is still valid.

   - Claim Usage:
   The recipient uses the claims in the payload to make access control and authorization decisions.
   For example, the recipient may check the "sub" claim to identify the user or the "exp" claim to verify if the token is still valid.

   - Token Refresh (Optional):
   If a JWT has a short expiration time, the client or server may need to request a new token by re-authenticating or using a refresh token. This depends on the token's design and use case.

 **Revocation (Optional)**:
    - In some systems, JWTs can be revoked if necessary. This typically involves maintaining a list of revoked tokens.


## 12. Do you use any Encoder to encode Password?

developers typically use cryptographic hash functions to securely store and verify passwords. Here's how it works:

1. **Password Hashing**: When a user creates or updates their password, the application doesn't store the actual password. Instead, it generates a one-way cryptographic hash of the password. A cryptographic hash is a fixed-length string generated from variable-length input data, and it's computationally infeasible to reverse the process (i.e., obtain the original password from the hash).

2. **Salting**: To enhance security, a random value known as a "salt" is generated for each user's password. The salt is added to the password before hashing. Salting ensures that even if two users have the same password, their hash values will be different because of the unique salt.

3. **Storage**: The application stores the salt and the password hash in its database. If an attacker gains access to the database, they won't have the actual passwords, only the salt and hash values.

4. **Verification**: When a user attempts to log in, the application retrieves the salt and password hash associated with the user. It then combines the entered password with the stored salt and hashes it. If the computed hash matches the stored hash, the password is considered valid.

Many programming languages and frameworks provide libraries and functions for securely hashing and verifying passwords. For example:

- In Java, you can use libraries like BCrypt or Argon2 for password hashing.
- In Python, the `passlib` library provides a convenient way to hash and verify passwords.
- In PHP, the `password_hash` and `password_verify` functions are commonly used for password hashing.

These libraries implement secure password hashing algorithms and take care of generating and managing the salt.


## 13. What is UserDetailService? AuthenticationProvider?AuthenticationManager? AuthenticationFilter?(把这几个名字看熟悉也行)

```
    - The `UserDetailsService` provides user information, 

    - the `AuthenticationProvider` validates credentials, 

    - the `AuthenticationManager` orchestrates the authentication process. 

    - the authentication filters play a key role in processing authentication requests and handling different authentication mechanisms
```

1. **UserDetailsService**:
   - The `UserDetailsService` interface in Spring Security is used to <u>retrieve user-related data for authentication and authorization</u>. It typically provides user information, including the username, password, and authorities, from a data source such as a database or an external system.
   - You <u>need to implement the `loadUserByUsername(String username)` method</u>, which takes a username as input and returns a `UserDetails` object representing the user's details. `UserDetails` includes information about the user and their granted authorities.

2. **AuthenticationProvider**:
   - An `AuthenticationProvider` is responsible for <u>authenticating a user based on their credentials (e.g., username and password) and creating an `Authentication` object</u>.
   - Spring Security typically uses one or more `AuthenticationProvider` instances to validate user credentials. You can configure multiple authentication providers for different authentication mechanisms, such as database authentication, LDAP authentication, and more.
   - The most common implementation of `AuthenticationProvider` is the `DaoAuthenticationProvider`, which validates user credentials against a `UserDetailsService`.

3. **AuthenticationManager**:
   - The `AuthenticationManager` is a central component in Spring Security that coordinates the authentication process. <u>It acts as a container for `AuthenticationProvider` instances</u>. 不干啥事，相当于一个interface
   - When a user attempts to log in, the `AuthenticationManager` sequentially delegates the authentication process to each configured `AuthenticationProvider` until one of them successfully authenticates the user.
   - Developers can customize and configure the `AuthenticationManager` to define how authentication should be handled.

4. **AuthenticationFilter** 
   - An `AuthenticationFilter` (or authentication filter) is not a standard component in Spring Security but refers to the various filters within the Spring Security Filter Chain.
   - <u>Spring Security uses a series of filters (e.g., `UsernamePasswordAuthenticationFilter`, `BasicAuthenticationFilter`) to intercept and process authentication requests</u>. These filters handle tasks like processing login forms, HTTP basic authentication, and more.
   - The filters work together to authenticate users and establish a user's security context based on the provided credentials.


## 14. What is the disadvantage of Session? how to overcome the disadvantage?

1. **Server Resource Usage**:
   - **Disadvantage**: Storing session data on the server can <u>consume server resources, particularly if many users have active sessions</u>.
   - **Overcoming**: 
        - <u>limit the data stored in sessions to only what is necessary</u>.  将会话中存储的数据限制为仅必要的数据。
        - <u>Implement session timeout policies</u> to automatically clean up inactive sessions.  实施会话超时策略以自动清理非活动会话。
        - <u>use server clustering or session persistence mechanisms to distribute session data across multiple servers</u> for better  考虑使用服务器集群或会话持久性机制在多个服务器之间分发会话数据，以获得更好的可扩展性。scalability.

2. **Statelessness**:
   - Disadvantage: <u>Sessions introduce some level of statefulness</u> in otherwise stateless HTTP, which can complicate scalability and load balancing.
   - Overcoming: <u>Use stateless session management approaches like JSON Web Tokens (JWTs) or OAuth2</u>, which don't rely on server-side session storage. These mechanisms store session data in the client's browser, reducing server-state requirements.

3. **Session Management**:
   - Disadvantage: <u>Managing sessions can be complex, especially when dealing with distributed systems and handling aspects like session fixation, session timeout, and session data synchronization</u>.
   - Overcoming: <u>Utilize established session management libraries and frameworks provided by your web application framework (e.g., Spring Session for Spring applications)</u> to handle common session-related tasks. Be aware of common session security threats and follow best practices.


## 15. how to get value from application.properties?

In a Spring application, you can access values from the `application.properties` file (or `application.yml` for YAML configuration) using the Spring `Environment` and <u>the `@Value` annotation</u>. 

The `@Value` annotation injects values from the Spring `Environment` and resolves them based on the property keys you <u>specify in `${...}` syntax</u>. The `${...}` placeholders are replaced with the corresponding property values defined in the `application.properties` file.

Keep in mind that to use the `@Value` annotation, you need to ensure that your class is a Spring-managed bean, which is typically done by annotating the class with `@Component`, `@Service`, or other Spring annotations, or by configuring it in your Spring application context.

Additionally, if you're working with a Spring Boot application, the `@Value` annotation is automatically enabled, and Spring Boot loads properties from `application.properties` by default.

Here's how you can do it:

1. **Create or Update `application.properties`**:
   - Ensure you have an `application.properties` file in your project's classpath. This file can be located in the `src/main/resources` directory. If you are using YAML format, you would use `application.yml`.

2. **Define Properties in `application.properties`**:
   - In your `application.properties` file, define properties with key-value pairs. For example:
     ```properties
     app.title=My Application
     app.version=1.0
     app.api.key=secret_key
     ```

3. **Inject Property Values**:
   - You can inject these property values into your Spring components, such as beans, controllers, or services, using the `@Value` annotation.

   ```java
   import org.springframework.beans.factory.annotation.Value;
   
   @Component
   public class MyComponent {
       @Value("${app.title}")
       private String applicationTitle;

       @Value("${app.version}")
       private String applicationVersion;

       @Value("${app.api.key}")
       private String apiKey;

       public void doSomething() {
           System.out.println("Title: " + applicationTitle);
           System.out.println("Version: " + applicationVersion);
           System.out.println("API Key: " + apiKey);
       }
   }
   ```

4. **Use Injected Properties**:
   - The values of these properties are injected into the corresponding fields in your component. You can use them as needed.


## 16. What is the role of configure(HttpSecurity http) and configure(AuthenticationManagerBuilder auth)?

<u>In Spring Security</u>, `configure(HttpSecurity http)` and `configure(AuthenticationManagerBuilder auth)` are <u>two important methods that you can override</u> in a class that extends `org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter`. 

The primary roles of these methods are as follows:
- `configure(HttpSecurity http)`: Defines how different parts of your application are secured, including specifying which URLs require authentication and authorization and configuring various security features.
- `configure(AuthenticationManagerBuilder auth)`: Specifies how user authentication is handled, such as defining define where user details are stored (e.g., in-memory, database, LDAP), define user credentials, roles, and authentication mechanisms.

1. **`configure(HttpSecurity http)`**:
   - This method is used to configure security-related aspects of your web application, primarily focusing on access control and request-level security.
   - It <u>allows you to define rules for which URLs require authentication and authorization and configuring various security features.</u>. You can specify which endpoints require authentication, authorization, and what access control rules should apply.
   - You can configure settings such as form-based authentication, HTTP basic authentication, logout behavior, CSRF protection, session management, and more.
   - Example usage:
     ```java
     @Override
     protected void configure(HttpSecurity http) throws Exception {
         http
             .authorizeRequests()
                 .antMatchers("/public/**").permitAll() // Public resources
                 .antMatchers("/user/**").hasRole("USER") // Restricted to users with the "USER" role
                 .antMatchers("/admin/**").hasRole("ADMIN") // Restricted to users with the "ADMIN" role
                 .anyRequest().authenticated() // All other requests require authentication
             .and()
             .formLogin() // Enable form-based authentication
                 .loginPage("/login") // Custom login page
                 .permitAll()
             .and()
             .logout() // Enable logout functionality
                 .logoutUrl("/logout")
                 .permitAll();
     }
     ```

2. **`configure(AuthenticationManagerBuilder auth)`**:
   - This method is used to configure how Spring Security performs user authentication and user details retrieval. It focuses on authentication and the definition of user credentials.
   - You <u>can define where user details are stored (e.g., in-memory, database, LDAP), define user credentials, roles, and authentication mechanisms</u>.
   - Typically, you configure user credentials, such as username and password, and associate them with roles or authorities. You can also specify custom authentication providers or mechanisms.
   - Example usage with in-memory user details:
     ```java
     @Override
     protected void configure(AuthenticationManagerBuilder auth) throws Exception {
         auth
             .inMemoryAuthentication()
                 .withUser("user").password("{noop}password").roles("USER")
                 .and()
                 .withUser("admin").password("{noop}adminpassword").roles("USER", "ADMIN");
     }
     ```


## 17.  What is Spring security authentication and authorization?

**Authentication** is <u>the process of verifying the identity of a user or entity, ensuring that the user is who they claim to be</U>. 

**Authorization** is <u>the process of determines what an authenticated user is allowed to do within the application.</u>. It defines the user's permissions, rights, and access control rules.

## 18. (Optional)Assuming that the Redbook UI supports dark mode and multiple languages, when a user signs in, their preferences (such as dark-mode=true and lang=eng) will be read from the database. For the assignment, you can set a value like in the course materials; there is no need to actually read from a database. After signing in, observe the response header and cookie for related information. Continue calling other APIs and observe the request header or cookie for other information. After signing in, Spring Security will generate a session, and the JSESSIONID will be in the cookie. Try to obtain the session content through the JSESSIONID, and then log the session content using the log4j tool. Write the code based on the 08_04 branch.
a. get cookie by HttpServletRequest
```java
@RestController
public class CookieController {
    @GetMapping("/read-cookie")
    public String readCookie(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            for (Cookie cookie : cookies) {
                if ("myCookie".equals(cookie.getName())) {
                    return "Cookie value: " + cookie.getValue();
                }
            }
        }
        return "Cookie not found";
    }
}
```

b. Get cookie by @CookieValue
```java
@RestController
public class CookieController {
    @GetMapping("/read-cookie")
    public String readCookie(@CookieValue(value = "myCookie", required = false, defaultValue = "default-value") String myCookie) {
        return "Cookie value: " + myCookie;
    }
}
```

c.  Get Session
```java
import java.util.Enumeration;
import javax.servlet.http.HttpSession;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class SessionController {
    private static final Logger logger = LoggerFactory.getLogger(SessionController.class);
    
    @GetMapping("/log-session")
    public String logSession(HttpSession session) {
        Enumeration<String> attributeNames = session.getAttributeNames();
        
        logger.info("Session ID: {}", session.getId());
        
        while (attributeNames.hasMoreElements()) {
            String attributeName = attributeNames.nextElement();
            Object attributeValue = session.getAttribute(attributeName);
            logger.info("Attribute: {} - Value: {}", attributeName, attributeValue);
        }
        
        return "Session logged";
    }
}
```

## 19. Reading, 泛读一下即可，自己觉得是重点的，可以多看两眼。

https://www.interviewbit.com/spring-security-interview-questions/#is-security-a-cross-cutting-concern: Spring Security Interview Questionss

