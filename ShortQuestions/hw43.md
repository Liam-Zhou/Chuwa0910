2.
Spring is a powerful and lightweight framework used for application development. In broader terms, the Spring framework is a well-defined tool that supports several web applications using Java as a programming language.
Spring Boot is an extension of the Spring framework which eliminated the boilerplate configurations required for setting up a Spring application. It is a lightweight and powerful alternative to Spring, making it a top choice for developing Spring applications.
Benefits:
Ease of Use: You can start building applications with minimal setup. A huge reduction in Spring configuration setups is a big saver of time.
Microservices Ready: Spring Boot allows developers to create standalone applications, which are suitable for microservices architectures.

3.
IOC: Inversion of Control is a design principle in software engineering which inverts the flow of control compared to traditional control flow. In traditional programming, the custom code that expresses the purpose of the program calls into reusable libraries to take care of generic tasks, but with inversion of control, it's the framework that calls into the custom, or task-specific, code.
DI: Dependency Injection is a technique to achieve IoC between classes and their dependencies.

4.
@ComponentScan is an annotation used in Spring Framework, which is used with Java configuration to specify the packages to scan for annotated components. These annotations mark the classes as spring components, which Spring will automatically discover when the annotation-based configuration and classpath scanning is used.

5.
In Spring, you can define the packages to be scanned for components both using XML configuration and Annotation-based configuration. Both of these methods allow Spring to know which packages to scan for classes annotated with @Component, @Service, @Repository, and @Controller, amongst others.

6.
Spring Boot @SpringBootApplication annotation is used to mark a configuration class that declares one or more @Bean methods and also triggers auto-configuration and component scanning.

7.
Annotations: @Component, @Service, @Repository, @Controller, @Bean, @RestController ,@ControllerAdvice
Defining beans in an XML file.
Using @ComponentScan for scanning specified packages for components.




8.
The default bean name for a component will be the uncapitalized non-qualified class name. That is, it takes the name of the class and converts the first character to lowercase.

If @Bean is used and a name is not specified, the default name of the bean is the name of the annotated method.

9.
@Component is a generic stereotype for any Spring-managed component. It indicates that the class is a Spring component and is to be autodetected when using annotation-based configuration and classpath scanning.
@Service is a specialization of @Component and has the same usage and functionality, but it is intended to indicate that the class is a service, which means it holds business logic.
@Repository is another specialization of @Component that provides additional benefits specifically for DAOs (Data Access Objects) or repository classes that access the database. 

10.
@Autowired @Inject @Resource @Qualifier @Value
Constructor Injection, Setter Injection

11.
Field injection, Constructor Injection, Setter Injection

Constructor Injection is generally recommended and has several advantages:
Immutable Fields: The fields that are injected via the constructor can be marked as final, which ensures that they cannot be modified once set.
Simplified Testing: It’s easy to provide dependencies in tests, as they can be passed via constructor when instantiating the object.
Ensures Valid State: It ensures that an object is in a valid state when it’s instantiated because if the required dependencies are not provided, the object will not be created.
Avoiding Circular Dependencies: Constructor injection helps in revealing circular dependencies at the object creation time.

12.
Using @Primary or @Qualifier
use @Resource annotation which works somewhat similar to @Autowired, but it performs the injection by name rather than type.

13.
BeanFactory
Basic IOC Container: BeanFactory is the root interface for accessing a Spring IOC container. It provides fundamental features needed to obtain beans.
Lazy Initialization: BeanFactory utilizes lazy initialization of beans, meaning beans are created only when they are requested, which can be useful for minimizing resource usage.
Lightweight: BeanFactory is lightweight and is recommended for simple scenarios where the overhead of an ApplicationContext is not justified.
Use-Cases: Ideal for simple use-cases and scenarios where resources are constrained and minimal functionality is needed.
No Support for Internationalization, Annotation-Based AOP, and Transaction Management: These features (and others) are not directly available in BeanFactory and might require additional configuration if they are necessary.

ApplicationContext
Advanced IOC Container: ApplicationContext is a more advanced and feature-rich container compared to BeanFactory. It includes everything BeanFactory offers and much more.
Eager Initialization: By default, ApplicationContext initializes all singleton beans upon context startup, which is useful when quick failure is desired (if there are issues with bean configurations).
Heavyweight: It is heavyweight due to its additional functionalities and is recommended for most enterprise applications.
Support for Internationalization, Event Propagation, and Declarative Mechanisms to Create a Singleton or Prototype Bean: ApplicationContext includes many enterprise-centric features, making it suitable for a wide range of application scenarios.
Various Context Types: ApplicationContext comes with various specialized types of contexts, like ClassPathXmlApplicationContext, FileSystemXmlApplicationContext, AnnotationConfigApplicationContext, etc.

In short, the BeanFactory provides the configuration framework and basic functionality, while the ApplicationContext adds enhanced capabilities to it, some of them perhaps more J2EE and enterprise-centric

14.
In Spring Framework, the scope of a bean defines the lifecycle and visibility of that bean instance. Different scopes allow beans to exist in different lifetimes, offering a flexible way to control object creation and management.

Singleton Scope (Default Scope)
Scope Keyword: singleton
Lifetime: A single instance of the bean is created and shared across the entire Spring container.
Use Case: This scope is ideal for stateless beans or service objects that don’t maintain any conversational state.

Prototype Scope
Scope Keyword: prototype
Lifetime: A new instance is created each time the bean is requested.
Use Case: Useful for stateful beans where the instance is used to complete a single operation and is disposed of.

Request Scope
Scope Keyword: request
Lifetime: A new bean is created for each HTTP request.
Use Case: Suitable for storing user preferences, input data, or any data that should not be shared across multiple HTTP requests.

Session Scope
Scope Keyword: session
Lifetime: A new bean instance is created for a user session.
Use Case: Useful for user tracking across multiple HTTP requests within the same session, such as storing user settings, authenticated user info, etc.

Application Scope
Scope Keyword: application
Lifetime: A single bean instance is used across the whole ServletContext while the application is running.
Use Case: Useful for sharing global configuration or state for all users in a web application.

WebSocket Scope
Scope Keyword: websocket
Lifetime: The bean exists for the lifecycle of a WebSocket.
Use Case: Useful for managing state in a WebSocket session, ensuring data is isolated to a particular WebSocket connection.


