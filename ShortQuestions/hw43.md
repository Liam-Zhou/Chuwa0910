1. List all of the annotations you learned from class and homework to annotaitons.md<br>
The answer in the annotaitons-Spring.md file.<br>


2. What is Spring and Springboot? What is the benfits of using Srpingboot?<br>
The Spring Framework is a comprehensive and modular framework for building Java-based enterprise applications. It provides a broad range of features, including dependency injection, aspect-oriented programming, data access, messaging, and more. Spring simplifies many aspects of Java application development.<br>
Spring Boot is an extension of the Spring Framework that simplifies the setup and development of Spring applications. It provides a set of conventions and tools to get a Spring application up and running quickly.<br>
Benefits of Using Spring Boot:Rapid Development: Spring Boot's opinionated defaults and auto-configuration features reduce the amount of boilerplate code you need to write, allowing you to develop applications quickly. Microservices: Spring Boot is well-suited for building microservices and RESTful APIs, making it easier to create and manage a fleet of microservices. Integration: It integrates seamlessly with other Spring projects and third-party libraries, which is essential for building enterprise-level applications. Production-Ready: Spring Boot offers built-in features for monitoring, security, and scalability, which are essential for deploying applications in production environments.


3. What is IOC and What is DI?<br>
IoC is a design principle and a pattern that shifts the control over the flow of a program's execution from the program itself to an external framework or container. In a traditional, imperative programming model, the application code controls the flow of execution. In contrast, IoC allows an external entity to control the flow.<br>
Dependency Injection is a specific technique used to implement the IoC principle. In DI, the dependencies that an object requires to function are provided (injected) from the outside, rather than the object creating or managing its own dependencies. Dependencies can be services, data sources, or other objects that an object relies on to perform its tasks.<br>


4. What is @CompnonentScan?<br>
The @ComponentScan annotation is a key component in the Spring Framework, specifically in the context of Spring's component scanning and auto-discovery mechanism. This annotation is used to specify the base package(s) that Spring should scan to discover and register Spring components such as @Component, @Service, @Repository, and @Controller classes, as well as other Spring-managed beans.<br>


5. How to define which package spring need to scan in xml and annotaiton?<br>

Annotations:<br>
``` 
@Configuration
@ComponentScan(basePackages = "com.chuwa.spring")
public class AppConfig {
    do something
}
``` 
XML:<br>
``` 
<context:component-scan base-package="com.chuwa.spring"/>
``` 
6. What is @SpringbootApplication?<br>
@SpringBootApplication is a convenient annotation in the Spring Boot framework. It is a combination of several annotations used to simplify the configuration of a Spring Boot application. This annotation is typically placed on the main application class of a Spring Boot application and combines the following annotations:


7. How many ways wo can define a bean?<br>
Using Annotations such as:@Component, @Service, @Repository, @Controller.
XML Configuration:
``` 
<bean id="myBean" class="com.example.MyBean"/>
``` 
Java Configuration:@Configuration,@Bean<br>


8. What is default bean name for @Component and @Bean?<br>
@Component: to mark a class as a Spring-managed component, the default bean name is generated from the class name with the first letter in lowercase. For example, if you have a class named MyComponent, the default bean name will be "myComponent."
@Bean: define a bean using the @Bean annotation in a configuration class, the default bean name is generated from the method name. For example, if you have a method named myBean that produces a bean, the default bean name will be "myBean."<br>


9. What is the difference between @component and @service,@repository?<br>
@Component for generic, non-specific beans.<br>
@Service to indicate that a class represents a service or business logic component.<br>
@Repository to mark classes that handle data access, especially when working with databases.<br>


10. How many annotaitons we can use to inject the bean?<br>
@Autowired: The @Autowired annotation is the most commonly used annotation for injecting beans. It allows you to automatically inject dependencies by type. You can use it on fields, constructor parameters, or setter methods<br>
@Qualifier: When multiple beans of the same type exist in the Spring context, you can use the @Qualifier annotation in conjunction with @Autowired to specify which bean to inject by providing the bean name.<br>
@Resource: The @Resource annotation is a standard Java EE annotation for dependency injection. It can be used to inject beans by name or by type<br>
@Inject: The @Inject annotation is another standard Java EE annotation for dependency injection. It is similar to @Autowired but provides more fine-grained control.<br>


11. Tell me the three types to do dependency injection(How can we inject the beans in Spring)? Which way is better and why?<br>
Constructor Injection:In constructor injection, dependencies are injected through a class constructor. Constructor injection is considered a robust and preferred method of DI because it ensures that all mandatory dependencies are provided at the time of object creation. It results in objects that are in a valid state from the start. Constructor injection promotes immutability, making the object's state unmodifiable once constructed. It can simplify testing as you can easily provide mock or test instances for the dependencies when creating an object for testing. It's particularly useful when the class has mandatory dependencies that are required for proper functioning.<br>
Setter Injection:Setter injection involves providing setter methods in a class to allow dependencies to be injected. Setter injection is more flexible than constructor injection because it allows you to change or update dependencies after object creation. It is useful when dealing with optional or mutable dependencies, but it can make objects mutable and may require additional checks to ensure proper initialization. Setter injection is often used in conjunction with @Autowired or other injection annotations.<br>
Method Injection:Method injection involves injecting dependencies through specific methods. This approach is less common than constructor and setter injection and is used when specific methods require dependencies for their operation. It allows you to inject dependencies dynamically into certain methods when needed. It is a suitable choice for managing context-specific dependencies, and it offers fine-grained control over dependency injection.<br>

Constructor injection is generally preferred when the class has mandatory dependencies that are essential for its proper operation. It enforces a valid and immutable state, making the code more robust and testable.<br>


12. If we have multiple beans for one type, how to set one is primary? and how to let the spring to pick one bean to inject if no primary.<br>
In Spring, when you have multiple beans of the same type and you want to specify one of them as the primary candidate for injection, you can use the @Primary annotation. The @Primary annotation marks one bean as the primary candidate when there are multiple candidates of the same type. The primary candidate will be injected when the type is requested without a specific qualifier.<br>
If no primary candidate is specified and no qualifier is used, Spring will use the default name of the field or parameter for injection.<br>


13. What is the difference between BeanFactory and ApplicationContext in Spring?<br>
In the Spring Framework, both BeanFactory and ApplicationContext are used to manage and provide access to beans in an application.<br>
BeanFactory:Core Container,Lazy Initialization,Resource Consumption,Limited Features,Customization.<br>
ApplicationContext:Complete Container,Eager Initialization,Resource Consumption,Rich Features.<br>

If you need a lightweight container with basic bean management capabilities, BeanFactory can be a suitable choice. It's resource-efficient and allows lazy initialization.<br>
If you require a full-featured container with additional features like AOP, internationalization, and event handling, and you are comfortable with eager initialization of singletons, then ApplicationContext is the better choice.<br>


14. What is the Scope of a Bean? and list the examples for each scope.<br>
In the Spring Framework, the scope of a bean defines the lifecycle and visibility of that bean within the Spring container. Different scopes determine when and how many instances of a bean are created and how they are shared among components. Spring provides several bean scopes to cater to different use cases.
Singleton (default),Prototype.<br>
For web: Request,Session,Application(ServletContext),WebSocket,Custom Scopes.<br>


15. Configure a bean using xml. If bean has parameters/dependencies, how can we
    configure the bean? (you can google the tutorial how to configure beans in xml,
    and feel free to ask me any quesitons if you don't understand. it is a little bit old,
    I am not sure if I need to exaplain it in class)<br>
Student.java
``` 
package com.chuwa.spring.example.entity;

public class Student {
    private int id;
    private String name;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}
``` 
beans.xml
``` 
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" "http://www.springframework.org/dtd/spring-beans.dtd">
<beans>
    <bean id="student" class="com.chuwa.spring.example.entity.Student"></bean>
</beans>
``` 

Main
``` 
package org.example;
import com.chuwa.spring.example.entity.Student;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
public class Main {
    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
        Student student  = (Student) ctx.getBean("student");
        student.setId(1);
        student.setName("Jun Wang");
        System.out.println(student.toString());
    }
}
``` 
![img.png](img.png)

