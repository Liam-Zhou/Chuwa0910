### 1. List all of the annotations you learned from class and homework to annotaitons.md

Here is a list of all the annotations I learned from class and homework:

* @Entity: Marks a class as an entity that can be persisted to a database.
* @Id: Marks a field as the primary key of an entity.
* @GeneratedValue: Marks a field as a generated value, such as an auto-incrementing ID.
* @Column: Marks a field as a column in a database table.
* @Table: Marks a class as being mapped to a specific database table.
* @OneToOne: Marks a relationship between two entities where each entity can only have one other entity.
* @OneToMany: Marks a relationship between two entities where each entity can have many other entities.
* @ManyToOne: Marks a relationship between two entities where each entity can only have one other entity.
* @ManyToMany: Marks a relationship between two entities where each entity can have many other entities.
* @Embedded: Marks a field as being embedded in the database table of the containing entity.
* @Transient: Marks a field as being ignored by JPA.
* @Inheritance: Marks a class as being an inheritance strategy for other entities.
* @DiscriminatorColumn: Specifies the column that is used to store the discriminator value for an inheritance strategy.
* @DiscriminatorValue: Specifies the discriminator value for an entity in an inheritance strategy.
* @SequenceGenerator: Specifies a sequence generator to be used for generating values for a field.
* @TableGenerator: Specifies a table generator to be used for generating values for a field.
* @NamedQuery: Specifies a named query that can be executed using JPA.


### 4.	what is JPA? and what is Hibernate?

* JPA (Java Persistence API): JPA is a Java specification for accessing, managing, and persisting data between Java objects and relational databases. It provides a standard way for Java applications to interact with databases.

* Hibernate: Hibernate is a popular, open-source implementation of the Java Persistence API (JPA). It is a powerful and flexible framework for Java applications to interact with databases. Hibernate provides an object-relational
mapping (ORM) solution to map Java objects to database tables and vice versa.

### 5.	What is Hiraki? what is the benefits of connection pool?

Hiraki is a connection pool for PostgreSQL. It is designed to improve the performance and scalability of PostgreSQL applications.

The benefits of connection pool include:

* Improved performance: Connection pools can improve the performance of database applications by reducing the number of times that a new connection needs to be created.
* Increased scalability: Connection pools can increase the scalability of database applications by allowing more connections to be open simultaneously.
* Reduced costs: Connection pools can reduce the costs of running database applications by reducing the number of database connections that need to be maintained.
  
### 6.	What is the @OneToMany, @ManyToOne, @ManyToMany? write some examples.

@OneToMany: This annotation is used to map a one-to-many relationship between two entities. For example, a Post entity can have many Comment entities.

Example:

```Java
@Entity
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;

    private String content;

    @OneToMany(mappedBy = "post")
    private List<Comment> comments;

    // getters and setters
}

@Entity
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String text;

    @ManyToOne
    private Post post;

    // getters and setters
}
```
@ManyToOne: This annotation is used to map a many-to-one relationship between two entities. For example, a Comment entity can only belong to one Post entity.

Example:

```java
@Entity
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String title;

    private String content;

    // getters and setters
}

@Entity
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String text;

    @ManyToOne
    private Post post;

    // getters and setters
}
```

@ManyToMany: This annotation is used to map a many-to-many relationship between two entities. For example, a User entity can belong to many Role entities, and a Role entity can have many User entities.

Example:

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;

    private String password;

    @ManyToMany
    private Set<Role> roles;

    // getters and setters
}

@Entity
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToMany(mappedBy = "roles")
    private Set<User> users;

    // getters and setters
}
```
### 7.	What is the cascade = CascadeType.ALL, orphanRemoval = true? and what are the other CascadeType and their features? In which situation we choose which one?

cascade = CascadeType.ALL: This option tells JPA to cascade all operations to the associated entities. For example, if you delete a Post entity, JPA will also delete all of the associated Comment entities.

orphanRemoval = true: This option tells JPA to delete any orphaned entities. For example, if you remove a Comment entity from a Post entity, JPA will delete the Comment entity from the database.

When to choose which CascadeType:

* CascadeType.ALL: This option is typically used when you want to maintain a consistent state between the parent entity and the associated entities.
* orphanRemoval = true: This option is typically used when you want to avoid orphaned entities in the database.
* Other CascadeType values: These options are typically used when you want to control how JPA cascades operations to the associated entities.

### 8.	What is the fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the difference? In which situation you choose which one?

* FetchType.LAZY: Lazy loading means that the data is loaded on demand, i.e., when the data is requested. It is suitable for large associations where you want to avoid loading unnecessary data initially.
* FetchType.EAGER: Eager loading means that the associated data is loaded immediately with the main entity. It is suitable for small associations where you always need the associated data.

### 9.	What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?

JPA uses naming conventions to generate queries automatically based on the method names in the repository interface. For example, to find a user by username:

```Java
Optional<User> findByUsername(String username);
```
