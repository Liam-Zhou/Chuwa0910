2: Type the Comment feature for the class project
```java

```

4: what is JPA? and what is Hibernate?
```text
JPA: Java Persistence API
Hibernate: ORM framework
```

5: What is Hiraki? what is the benefit of using it?
```text
Hiraki: Connection Pool
the benefit is to avoid the overhead of creating and destroying connections
```

6: What is the @OneToMany, @ManyToOne, @ManyToMany?

```java
import jdk.jfr.Enabled;

@Entity
class A {
    @OneToMany
    @MappedBy("a")
    private List<B> bs;
}

@Entity
class B {
    @ManyToOne
    private A a;
}

@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @ManyToMany
    @JoinTable(
            name = "student_course",
            joinColumns = @JoinColumn(name = "student_id"),
            inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private List<Course> courses;
    // Getters and setters
}

@Entity
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;

    @ManyToMany(mappedBy = "courses")
    private List<Student> students;
    // Getters and setters
}
```

7: What is the  cascade = CascadeType.ALL, orphanRemoval = true? and what
are the other CascadeType and their features? In which situation we choose
which one?
```text

CascadeType.ALL: This option specifies that all operations (insert, update, delete, etc.) on the owning entity should cascade to its associated entities.
CascadeType.PERSIST: Cascades the persist operation (insert) to the associated entities.
CascadeType.MERGE: Cascades the merge operation (update) to the associated entities.
CascadeType.REMOVE: Cascades the remove operation (delete) to the associated entities.
CascadeType.REFRESH: Cascades the refresh operation to the associated entities.
CascadeType.DETACH: Cascades the detach operation to the associated entities.
```

8: What is the  fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the
difference? In which situation you choose which one?
```text
LAZY: only fetch when needed
EAGER: fetch immediately
Use FetchType.LAZY when you have associations that are not always needed, especially when they involve large amounts of data. Lazy loading can help optimize performance by avoiding unnecessary database queries.
Use FetchType.EAGER when you know that you will consistently need the associated data every time you fetch the owning entity. Eager loading can simplify your code by ensuring that all required data is available immediately, but it may lead to performance issues if used indiscriminately, as it can load unnecessary data.
```

9: What is the rule of JPA naming convention? Shall we implement the method by
ourselves? Could you list some examples?
```text

In Java Persistence API (JPA), there are naming conventions that help determine the default database table and column names for entities and their attributes. These conventions are useful when you want to let JPA automatically generate the database schema based on your entity classes. However, you can also provide explicit mapping using annotations to override the default naming conventions if needed.

Here are some of the common naming conventions used in JPA:

Entity Class Names:
By default, JPA assumes that the entity class name corresponds to the table name in the database. The table name is typically converted to uppercase, and underscores may be added between words if the class name is in camelCase. For example:
Author entity class maps to the AUTHOR table.
BookCategory entity class maps to the BOOK_CATEGORY table.
Attribute Names:
By default, JPA assumes that entity attribute names correspond to column names in the database table. Again, the column name is typically converted to uppercase, and underscores may be added between words if the attribute name is in camelCase. For example:
An attribute named firstName in an entity maps to the FIRST_NAME column.
An attribute named publicationYear in an entity maps to the PUBLICATION_YEAR column.
Primary Key Columns:
The primary key column name is typically generated based on the entity name and is suffixed with _ID. For example:
The primary key column for the Author entity would be named AUTHOR_ID.
Join Table Names (for Many-to-Many relationships):
In a many-to-many relationship, the default join table name is generated by concatenating the names of the two entities involved in alphabetical order. For example, if you have a many-to-many relationship between Author and Book, the default join table would be named AUTHOR_BOOK.
Foreign Key Columns:
Foreign key columns typically follow the pattern of the referenced entity's primary key column name. For example, if you have a foreign key from Book to Author, it would be named AUTHOR_ID by default.
It's important to note that while these naming conventions are convenient, they are not mandatory. You can override the default behavior and specify custom table and column names using JPA annotations like @Table, @Column, and @JoinColumn. This can be useful when you're working with an existing database schema that doesn't follow the JPA naming conventions or when you want to use more meaningful names in your database.

Here are some examples of overriding the naming conventions with JPA annotations:
@Entity
@Table(name = "authors")
public class Author {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "author_id")
    private Long id;

    @Column(name = "full_name")
    private String fullName;

    // ...
}

@Entity
@Table(name = "books")
public class Book {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "book_id")
    private Long id;

    @Column(name = "title")
    private String bookTitle;

    // ...
}
```
14: What is JPQL?
```text
JPQL stands for Java Persistence Query Language. It is a platform-independent object-oriented query language used to define database queries. It is similar to SQL but operates on objects, attributes, and relationships instead of tables and columns. JPQL is used to perform database operations on entities and their persistent state.
```
What is @NamedQuery and @NamedQueries?
```text
@NamedQuery and @NamedQueries are JPA (Java Persistence API) annotations used to define named queries for retrieving data from a database using the query language provided by JPA (usually JPQL - Java Persistence Query Language). Named queries allow you to define SQL-like queries in your Java code and then reference them by name, making it easier to reuse and manage queries in your application.
```

What is @Query? In which Interface we write the sql or JPQL?
```text
@Query is a Spring Data annotation that can be used to specify a custom SQL statement or JPQL query to be executed when a repository method is invoked. It can be used to perform database operations on entities and their persistent state.
```

What is HQL and Criteria Queries?
```text
Hibernate Query Language (HQL) is an object-oriented query language used to perform database operations on entities and their persistent state. It is similar to SQL but operates on objects, attributes, and relationships instead of tables and columns. HQL is used to define database queries in terms of entities and their persistent state, rather than database tables and columns.
```

What is EnityManager?
```text
The EntityManager is the primary interface used to interact with the persistence context. It is used to create and remove persistent entity instances, to find entities by their primary key, and to query over entities.
```

What is SessionFactory and Session?
```text
SessionFactory is an interface that is used to create Session objects. It is a factory of session and client of ConnectionProvider. It holds second-level cache (optional) of data. The org.hibernate.SessionFactory interface provides factory method to get the object of Session.
```

What is Transaction? how to manage your transaction?
```text
A transaction is a logical unit of work that contains one or more SQL statements. A transaction is an atomic unit. The effects of all the SQL statements in a transaction can be either all committed (applied to the database) or all rolled back (undone from the database).
```

What is hibernate Caching?
```text
Hibernate caching is a mechanism that helps us to store the data in the cache memory. So that we can use it in the future. It is a temporary memory of the computer. It is used to improve the performance of the application.
```

What is the difference between first-level cache and second-level cache?
```text
First-level cache is enabled by default and there is no way to disable it. It is associated with the Session object. Hibernate first-level cache is a session-specific cache, basically a Map collection that stores objects as key and their corresponding database record as value. It is enabled by default and cannot be disabled. Hibernate first-level cache is enabled only for the current running session. It is also known as the Session cache.
Second-level cache is disabled by default but can be enabled by setting the hibernate.cache.use_second_level_cache property to true. It is associated with the SessionFactory object. Hibernate second-level cache is a JVM-level (process-level) cache that is shared among all sessions. It is enabled for all sessions and is known as the SessionFactory cache.
```


How do you understand @Transactional?
```text
The @Transactional annotation is used to specify the transactional behavior of a method or class. It allows you to define the scope of a single database transaction or multiple transactions. It can be used with Spring and JPA to manage transactions.
```

what is the @configuration and @bean?
```text
@Configuration is a Spring annotation that indicates that the class is a configuration class that may contain bean definitions. The @Bean annotation tells Spring that a method annotated with @Bean will return an object that should be registered as a bean in the Spring application context.
```


How do you handle the exception in Spring?
```text
Use @ControllerAdvice and @ExceptionHandler
```
How do you do the validations in Spring? And list some validation annotaitons 
you know
```text
Spring provides a convenient way to validate data using the JSR-303 Bean Validation API. The Bean Validation API provides a set of annotations that can be used to validate data. Spring provides support for the following validation annotations:
@DecimalMax
@DecimalMin
@Digits
@Email
@Max
@Min
@Negative
@NegativeOrZero
@NotBlank
@NotEmpty
```

What is the actuator?
```text
Spring Boot Actuator is a sub-project of Spring Boot. It adds several production-grade services to your application with little effort on your part. In this guide, you will build an application and then see how to add these services.
```

What is MVC pattern?
```text
MVC stands for Model-View-Controller. It is a software design pattern that separates the representation of information from the user's interaction with it. The model is responsible for managing the data of the application. The view is responsible for displaying the data to the user. The controller is responsible for handling user input and updating the model and view accordingly.
```

What is Front-Controller? 
```text
The front controller design pattern is used to provide a centralized request handling mechanism so that all requests will be handled by a single handler. This handler can do the authentication/ authorization/ logging or tracking of request and then pass the requests to corresponding handlers.
```

What is DispatcherServlet? please decribe how it works
```text
The DispatcherServlet is the front controller in Spring MVC. It is responsible for handling all incoming requests and then dispatching them to the appropriate controller. It is a servlet that receives all incoming requests and then delegates them to the appropriate controller.
```

What is JSP and What is ModelAndViewï¼Ÿ
```text
JSP stands for JavaServer Pages. It is a technology that allows you to create dynamic web pages using Java. It is a server-side technology that is used to create web pages that are generated on the server and sent to the client. It is an extension of the Java Servlet technology.
ModelAndView is a class that holds both the model and view. It is used to pass data between the controller and the view. It is used to pass data from the controller to the view. It is used to pass data from the view to the controller.
```

Could you please google any other servlets
```text
Listener Servlet
Async Servlet
Filter Servlet
JSP Servlet
```

How many web server do you know? 
```text
Apache Tomcat
Jetty
GlassFish
WildFly
JBoss
```



