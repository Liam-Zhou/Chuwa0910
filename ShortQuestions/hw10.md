*******************************************
Q1. List all annotations you learned from class and homework to annotations.md

See update in annotations.md
*******************************************
Q2. Type the Comment feature for the class project.

Done.
*******************************************
Q3. In postman, call of the APIs in PostController and CommentController.

Done.
*******************************************
Q4. What is JPA? and what is Hibernate?

JPA is Java Persistence API, which is a specification for accessing, persisting, and managing data between Java objects and relational database. 
Hibernate is an implementation of JPA. 

JPA is a standard of Object Relational Mapping. It's an `interface` that defines a set of annotations for creating the object relational mapping. 

The most popular ORM framework is Hibernate. Hibernate is an implementation of JPA.
*******************************************
Q5. What is Hikari? what is the benefits of connection pool?

Hikari is a connection pool. It is a pool of connections to a database. It can efficiently manage the computer resource to avoid a large number of connections to the database.
*******************************************
Q6. What is the @OneToMany, @ManyToOne, @ManyToMany? write some examples.

@OneToMany: one to many relationship. Each student enrolled in many courses.
@ManyToOne: many to one relationship. Many comment to one post. 
@ManyToMany: many to many relationship. Will have a middle table. User and roles. 

@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String email;
    private String phone;
    @OneToMany(mappedBy = "student")
    private List<Enrollment> enrollments;
}

@Entity
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String description;
    @OneToMany(mappedBy = "course")
    private List<Enrollment> enrollments;
}

@Entity
public class Enrollment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    @ManyToOne
    private Student student;
    @ManyToOne
    private Course course;
    private String grade;
}
*******************************************
Q7. What is the `cascade = CascadeType.ALL, orphanRemoval = true?` and what
are the other CascadeType and their features? In which situation we choose
which one?

Cascade type: 
Persist: owning entity saved > related entity saved.
Merge: owning entity merged > related entity merged.
Remove: owning entity removed > related entity removed.
Refresh: owning entity refreshed > related entity refreshed.
Detach: owning entity detached > related entity detached.
All: all cascade operations on owning entity applied to related entity. 
*******************************************
Q8. What is the `fetch = FetchType.LAZY`, `fetch = FetchType.EAGER?` what is the
difference? In which situation you choose which one?

Eager or Lazy? 
Eager: When a record is fetched from the database, all the associated records from related tables are also fetched.  (Default fetch type by Hibernate).
Lazy: When a record is fetched from the database, associated records from related tables are not fetched. (Only fetch the data we request, no extra data.)
*******************************************
Q9. What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?

No, we do not need to implement the method by ourselves. 

For Entity: @Entity, entity class names should be singular and start with an uppercase letter, matching the table name they represent.
For Table: By default, JPA uses the name of the entity class as the table name and in lower case. 
For primary key: By default, the primary key field of an entity is assumed to be named "id".
For Field-Column Mapping: By default, JPA maps fields to columns with the same name. If no @column annotation is specified, and the variable is in camel case, the column name will be in snake case.
For Method name in Repository: JPA will automatically generate the SQL statement based on the method name.
*******************************************
Q10. Try to use JPA advanced methods in your class project. In the repository layer, you need to use the naming convention to use the method provided by JPA.

JPA Repository Basic method: findAll(), findAllById(), saveAll(), saveAndFlush(), saveAllAndFlush(), deleteInBatch()

Advanced method:
User findByLastName(lastname, b,c,d);
User findByLastNameAndFirstName(lastname, firstname);
List<Post> findByTitleOrDescription(a,b);

And, Or, Between, IsNull: findByAgeIsNull() where age is null? IsNotNull, NotNull, OrderBy, In, NotIn, True, False, IgnoreCase. 
*******************************************
Q11. (Optional) Check out a new branch(https://github.com/TAIsRich/springboot-redbook/tree/hw02_01_jdbcTemplate) from branch 02_post_RUD, replace the dao
layer using JdbcTemplate.
*******************************************
Q12. (Optional) use JDBC to read the data from database.
*******************************************
Q13. Type the code, you need to checkout new branch from branch 02_post_RUD,
name the new branch with https://github.com/TAIsRich/springboot-redbook/tree/hw05_01_slides_JPQL.
*******************************************
Q14. What is JPQL? 

JPQL is Java Persistence Query Language.
It is a query language used in the `Java Persistence API (JPA)`, which is a Java specification for managing relational data in Java applications.
JPQL is a platform-independent query language that allows you to express database queries in an object-oriented manner, 
targeting your domain model instead of the database schema.

1. Entity based query language
2. JPQL is designed to be database-agnostic
3. Integration with Spring Data JPA
*******************************************
Q15. What is @NamedQuery and @NamedQueries?

@NamedQuery is used to define a single named query for an entity class. You annotate the entity class with @NamedQuery and specify the query as a string using the query attribute. 
You can then reference this named query by its name and use it to execute the query.

@NamedQueries is used to define multiple named queries for an entity class. It allows you to group several named queries within a single annotation. You provide an array of @NamedQuery annotations to the @NamedQueries annotation.
*******************************************
Q16. What is @Query? In which Interface we write the sql or JPQL?

You can use the @Query annotation to define JPQL queries directly in your repository interface methods. 
*******************************************
Q17. What is HQL and Criteria Queries?

HQL is Hibernate Query Language. It is an object-oriented query language, similar to SQL, but instead of operating on tables and columns, HQL works with persistent objects and their properties.
*******************************************
Q18. What is EntityManager?

A JPA EntityManager manages connection to a database as well as to database operations. EntityManager is associated with a PersistenceContext. 
EntityManager is the interface to the Persistence Context. 
*******************************************
Q19. What is SessionFactory and Session?

Session object provides an interface between the application and data stored in the database. 

The Session is a lightweight, non-thread-safe object representing a single unit of work with the database. It is a short-lived object, and one Session is generally created for a specific interaction with the database.

The SessionFactory is a central, heavyweight, and thread-safe factory for creating and managing Hibernate Session instances.
The SessionFactory is responsible for configuring Hibernate, connecting to the database, and maintaining the cache of persistent objects.
*******************************************
Q20. What is Transaction? how to manage your transaction?

A transaction simply represents a unit of work. (If one step fails, the whole transaction fails)

Manage: To manage transactions, 
begin by starting a transaction, then execute the required database operations. 
If all operations succeed, commit the transaction to make changes permanent; 
if any operation fails, roll back the transaction to maintain data integrity.
*******************************************
Q21. What is hibernate Caching?

Hibernate provides 2 level cache: 

First-level cache: Hibernate first level cache is session specific, 
thatâ€™s why when we are getting the same data in same session there is no query fired whereas in other session query is fired to load the data.

Second-level cache: When an entity instance is looked up by its id and if
second-level caching is enabled for that entity, the following happens:

a. If an instance is already present in the first-level cache, it is returned
from there

b. If an instance is not found in the first-level cache, and the
corresponding instance state is cached in the second-level cache, then
the data is fetched from there and an instance is assembled and
returned

c.  Otherwise, the necessary data are loaded from the database and an
instance is assembled and returned
*******************************************
Q22. What is the difference between first-level cache and second-level cache?

The priority of the first-level cache is higher than the second-level cache.

First Level Cache: 
1. This is local to the Session object and
cannot be shared between multiple
sessions. 
2. This cache is enabled by default and
there is no way to disable it. 
3. The first level cache is available only
until the session is open, once the
session is closed, the first level cache is
destroyed.

Second Level Cache:
1. This cache is maintained at the
SessionFactory level and shared among all
sessions in Hibernate.
2. This is disabled by default, but we can enable
it through configuration.
3.The second-level cache is available through
the applicationâ€™s life cycle, it is only destroyed
and recreated when an application is
restarted.
*******************************************
Q23. How do you understand @Transactional?

For example: in a payment-order transaction,
If transaction success, it saved th related data to both the order table and payment table.
If one of method fails and throws an exception, the transaction will be rolled back,
If it saved data in one table, however failed in second table, it rollback.
*******************************************
Q24. Write a simple factory design pattern. 

Need to @EnableTransactionManagement in the application class. (main class)
Need to @Transactional in the service class. (Service Method)
Without @Transactional, We can deign a exception to handle the transaction. When it throws out, it failed. 
*******************************************


