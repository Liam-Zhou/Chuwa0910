# hw10 - Ke Chen - hw42 - Spring Data

## 1.  List all of the annotations you learned from class and homework to annotaitons.md
see files in coding : annotaitons.md

## 2.  Type the Comment feature for the class project.
```java
/**
 * Class Project: [Your Project Name]
 *
 * Description:
 * This class project is part of [Course Name] at [Your School/Institution].
 * It aims to [Briefly describe the purpose and objectives of your project].
 *
 * Team Members:
 * - [Your Name]: [Your Role]
 * - [Team Member 2 Name]: [Their Role]
 * - [Team Member 3 Name]: [Their Role]
 *   [Include more team members as needed]
 *
 * Date: [Date of Comment]
 *
 * Overview:
 * - [Provide a brief overview of the project's main goals and features]
 *
 * Technologies Used:
 * - Programming Language: [e.g., Java, Python, C++, etc.]
 * - Frameworks/Libraries: [List any relevant frameworks or libraries]
 * - Tools/IDEs: [List the development tools or Integrated Development Environments used]
 * - Version Control: [e.g., Git/GitHub]
 * - Database: [Specify if a database is used]
 *   [Include any other relevant technologies]
 *
 * Project Structure:
 * - [Describe the structure of the project, including major classes or modules]
 *
 * Key Features:
 * - [Highlight the project's key features and functionality]
 *
 * How to Run:
 * - [Provide instructions on how to run and test the project]
 *
 * Documentation:
 * - [Link to project documentation, if available]
 *
 * GitHub Repository:
 * - [Include a link to the project's GitHub repository, if applicable]
 *
 * Comments:
 * - [Include any additional comments or notes about the project]
 *
 * Note: This is a general project comment template. Customize it as needed to suit the specific details of your class project.
 */
```

## 3.  In postman, call of the APIs in PostController and CommentController.

done

## 4.  what is JPA? and what is Hibernate?

**JPA (Java Persistence API)** and **Hibernate** are both technologies related to Java-based data persistence and database access. 

They serve similar purposes but have different roles and characteristics:

1. **JPA (Java Persistence API)**:
   - JPA is <u>a standard Java API</u> for object-relational mapping (ORM)</u> that provides a set of interfaces and specifications for <u>mapping Java objects to relational databases</u>. It's part of the Java EE (Enterprise Edition) platform.
   - JPA is not an implementation but a specification. It defines a set of standard annotations and APIs that can be implemented by various ORM frameworks to achieve consistent and portable data access in Java applications.
   - Key components of JPA include the Entity class (Java class representing a database table), EntityManager (used for CRUD operations), and JPQL (Java Persistence Query Language for querying data).
   - Popular JPA implementations include Hibernate, EclipseLink, and Apache OpenJPA.

2. **Hibernate**:
   - Hibernate is <u>a widely used, open-source ORM framework</u> that <u>implements the JPA specification and provides additional features and capabilities</u>. It's one of the most popular and mature ORM solutions in the Java ecosystem.
   - While JPA defines a set of standard interfaces and annotations, Hibernate goes beyond the JPA standard and offers its own set of features and APIs. These additional features make Hibernate more powerful but potentially less portable compared to a pure JPA implementation.
   - Hibernate <u>provides an Object-Relational Mapping (ORM) layer that allows you to map Java objects to database tables, generate SQL queries, and perform database operations without writing explicit SQL statements</u>.
   - Hibernate also offers caching, support for lazy loading, and various optimization features, making it a comprehensive ORM solution.

In summary, JPA is a Java standard for ORM, while Hibernate is a popular ORM framework that implements the JPA standard, providing additional features and capabilities.

## 5.  What is Hikari? what is the benefits of connection pool?

**HikariCP**:
- HikariCP is <u>an open-source connection pooling library</u> for Java applications, <u>commonly used with JDBC (Java Database Connectivity) to manage database connections efficiently</u>.
- It is known for its exceptional performance, low overhead, and simple configuration. HikariCP is designed to be fast and lightweight, making it a popular choice in high-performance and scalable applications.

**Benefits of Connection Pooling**:
Connection pooling is a technique used to <u>manage and reuse database connections</u> in a way that offers several benefits:

1. **Resource Efficiency**: Database connections can be expensive to establish and tear down. Connection pooling maintains a pool of pre-established connections, reducing the overhead of creating and destroying connections for each database request.

2. **Performance Improvement**: Reusing existing connections from the pool is significantly faster than creating new ones for every database operation. This leads to better application performance and lower latency.

3. **Optimal Resource Utilization**: Connection pools limit the number of connections that can be open simultaneously, preventing resource exhaustion and ensuring efficient use of database resources.

4. **Connection Management**: Connection pools handle connection lifecycle tasks, such as opening, closing, and validating connections. This reduces the burden on application code and ensures that connections are properly managed.

5. **Concurrency Control**: Connection pools can control the number of concurrent requests and throttle access to prevent overloading the database. This helps maintain system stability.

6. **Load Balancing**: Some connection pool implementations can distribute connections across multiple database servers, improving database server load balancing and availability.

7. **Configuration Flexibility**: Connection pools are often highly configurable, allowing developers to fine-tune settings to match the application's specific needs.

8. **Connection Reuse**: Reusing connections within a single transaction or user session can ensure consistency and transaction integrity, as multiple operations can be part of the same database transaction.

9. **Fault Tolerance**: Connection pools can help manage and recover from database connection failures, improving the resilience of the application.


## 6.  What is the  @OneToMany, @ManyToOne, @ManyToMany? write some examples.
`@OneToMany`, `@ManyToOne`, and `@ManyToMany` are common annotations used in JPA (Java Persistence API) and Hibernate to <u>define relationships between entities in a relational database</u>. These annotations are used to specify the cardinality and direction of relationships between entities. Here are explanations and examples for each:

1. **@OneToMany**:
   - The `@OneToMany` annotation <u>indicates a one-to-many relationship between two entities, where one entity is associated with multiple instances of another entity</u>.
   - This annotation is typically placed on the "one" side of the relationship, and it is used to define a collection (e.g., a `List` or `Set`) of related entities.

   Example:
   ```java
   @Entity
   public class Author {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;
       private String name;

       @OneToMany(mappedBy = "author")
       private List<Book> books;

       // Constructors, getters, and setters
   }
   ```

   ```java
   @Entity
   public class Book {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;
       private String title;

       @ManyToOne
       @JoinColumn(name = "author_id")
       private Author author;

       // Constructors, getters, and setters
   }
   ```

2. **@ManyToOne**:
   - The `@ManyToOne` annotation <u>specifies a many-to-one relationship between two entities, where many instances of one entity can be associated with one instance of another entity</u>.
   - This annotation is typically placed on the "many" side of the relationship, indicating the owning side of the relationship.

   Example:
   ```java
   @Entity
   public class Book {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;
       private String title;

       @ManyToOne
       @JoinColumn(name = "author_id")
       private Author author;

       // Constructors, getters, and setters
   }
   ```

3. **@ManyToMany**:
   - The `@ManyToMany` annotation <u>signifies a many-to-many relationship between two entities, where multiple instances of one entity are associated with multiple instances of another entity</u>.
   - To represent a many-to-many relationship, an additional table (junction table) is created in the database to store the relationship mappings.

   Example:
   ```java
   @Entity
   public class Student {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;
       private String name;

       @ManyToMany
       @JoinTable(
           name = "student_course",
           joinColumns = @JoinColumn(name = "student_id"),
           inverseJoinColumns = @JoinColumn(name = "course_id")
       )
       private Set<Course> courses;

       // Constructors, getters, and setters
   }
   ```

   ```java
   @Entity
   public class Course {
       @Id
       @GeneratedValue(strategy = GenerationType.IDENTITY)
       private Long id;
       private String title;

       @ManyToMany(mappedBy = "courses")
       private Set<Student> students;

       // Constructors, getters, and setters
   }
   ```

## 7. What is the  cascade = CascadeType.ALL, orphanRemoval = true? and what are the other CascadeType and their features? In which situation we choose which one?

In JPA (Java Persistence API) and Hibernate, the `cascade` and `orphanRemoval` attributes are used to <u>define how the state of related entities should be managed when performing operations on the owning entity (the one that defines the relationship)</u>. These attributes are typically used in conjunction with the `@OneToMany` and `@ManyToMany` annotations to specify the cascade behavior.

Here's an explanation of `cascade` and some common `CascadeType` options:

1. **`cascade` Attribute**:
   - The `cascade` attribute of a JPA relationship annotation (e.g., `@OneToMany`, `@ManyToMany`) specifies the set of operations that should be cascaded from the owning entity to the related entities. These operations typically include persisting, merging, removing, and refreshing entities.

2. **`orphanRemoval` Attribute**:
   - The `orphanRemoval` attribute, when set to `true`, specifies that if a related entity is removed from the owning entity's collection (e.g., a `List` of related entities), it should be deleted from the database. This is useful for ensuring that orphaned entities (entities no longer referenced by any owning entity) are automatically removed from the database.

Now, let's look at common `CascadeType` options and their features:

- **`CascadeType.PERSIST`**: This option cascades the persist operation. When you persist an owning entity, related entities are also persisted.

- **`CascadeType.MERGE`**: This option cascades the merge operation. When you merge an owning entity, related entities are also merged.

- **`CascadeType.REMOVE`**: This option cascades the remove operation. When you remove an owning entity, related entities are also removed.

- **`CascadeType.REFRESH`**: This option cascades the refresh operation. When you refresh an owning entity, related entities are also refreshed.

- **`CascadeType.DETACH`**: This option cascades the detach operation. When you detach an owning entity, related entities are also detached.

- **`CascadeType.ALL`**: This option includes all of the above cascade operations: `PERSIST`, `MERGE`, `REMOVE`, `REFRESH`, and `DETACH`.

- **`CascadeType.DETACH`**: This option is used to cascade the persist operation, which is typically the default behavior. When you persist an owning entity, related entities are also persisted.

The choice of which `CascadeType` to use depends on the requirements of your application. Here are some considerations:

- Use `CascadeType.PERSIST` when you want related entities to be persisted when the owning entity is persisted.

- Use `CascadeType.REMOVE` when you want related entities to be removed when the owning entity is removed. You may also use `orphanRemoval = true` in combination with this to ensure orphaned entities are removed.

- Use `CascadeType.MERGE` and `CascadeType.REFRESH` when you want related entities to be synchronized and refreshed when the owning entity is merged or refreshed.

- Be cautious when using `CascadeType.ALL` because it includes all operations, which may lead to unexpected side effects. Carefully consider which operations should be cascaded in your specific use case.

The choice of `orphanRemoval` is typically used in combination with `CascadeType.REMOVE` to ensure that orphaned entities are automatically removed when they are no longer referenced by the owning entity. It's particularly useful when you have a composition relationship where related entities should not exist independently.

## 8.  What is the  fetch = FetchType.LAZY, fetch = FetchType.EAGER? what is the difference? In which situation you choose which one?
In JPA (Java Persistence API) and Hibernate, the `fetch` attribute is used to specify how related entities are fetched when a query is executed. It controls the loading behavior of associated entities within a particular relationship. There are two common options for the `fetch` attribute: `FetchType.LAZY` and `FetchType.EAGER`.

Here's an explanation of each and when to choose one over the other:

1. **FetchType.LAZY**:
   - When you specify `FetchType.LAZY`, related entities are loaded lazily, meaning they are not loaded from the database until they are accessed by your code.
   - With lazy loading, the related entities are represented as proxy objects or placeholders in memory until they are explicitly accessed. This can help improve performance by avoiding unnecessary loading of data.
   - Use `FetchType.LAZY` when you have relationships where you want to defer loading of related entities until they are actually needed, and you want to minimize the amount of data loaded upfront.

Example:
   ```java
   @ManyToOne(fetch = FetchType.LAZY)
   private Author author;
   ```

2. **FetchType.EAGER**:
   - When you specify `FetchType.EAGER`, related entities are loaded eagerly, meaning they are loaded from the database as soon as the owning entity is loaded.
   - With eager loading, the related entities are immediately loaded and available in memory when the owning entity is retrieved. This can be useful when you know that you will consistently need the related entities, and you want to minimize the number of database queries.
   - Use `FetchType.EAGER` when you have relationships where you know you'll frequently access the related entities and want to avoid additional database queries for lazy loading.

Example:
   ```java
   @OneToMany(fetch = FetchType.EAGER)
   private List<Book> books;
   ```

**Choosing Between FetchType.LAZY and FetchType.EAGER**:
The choice between `FetchType.LAZY` and `FetchType.EAGER` depends on the specific requirements of your application:

1. Use `FetchType.LAZY` when:
   - You want to optimize database query performance by loading related entities only when necessary.
   - You have relationships where related entities are not always needed and loading them eagerly would be wasteful.

2. Use `FetchType.EAGER` when:
   - You consistently access the related entities and want to minimize additional database queries.
   - You have relationships where related entities are expected to be used frequently and loading them lazily would lead to unnecessary overhead.

It's important to carefully consider your application's performance and data access patterns when choosing between these fetch types. You can also combine them within a single entity to control the loading behavior for different associations, tailoring it to the specific use case.

## 9.  What is the rule of JPA naming convention? Shall we implement the method by ourselves? Could you list some examples?

JPA (Java Persistence API) follows a set of naming conventions for entity classes and their properties to map them to database tables and columns. These conventions help simplify the mapping process, but they can also be customized if needed. Here are some common JPA naming conventions and examples:

1. **Entity Class Naming Convention**:
   - Entity classes are typically named in singular form, using camel case, and match the name of the database table they represent. The first letter of the class name is capitalized.

   Example:
   - Database Table: `student`
   - Entity Class: `Student`

2. **Table Naming Convention**:
   - By default, the name of the database table is derived from the name of the entity class. The table name follows the same camel case to underscore naming convention. 

   Example:
   - Entity Class: `Employee`
   - Database Table: `employee`

3. **Primary Key Naming Convention**:
   - The primary key field is typically named `id` in the entity class. It is annotated with `@Id` to specify that it's the primary key.

   Example:
   ```java
   @Id
   private Long id;
   ```

4. **Column Naming Convention**:
   - By default, the name of a column in the database table is derived from the name of the corresponding field in the entity class. The column name also follows the camel case to underscore naming convention.

   Example:
   ```java
   private String firstName;  // Maps to column "first_name" in the database table
   ```

5. **Relationships Naming Convention**:
   - For relationships between entities, JPA typically assumes that the name of the field in the owning entity (e.g., `@ManyToOne` or `@OneToMany` relationship) corresponds to the name of the related entity's primary key.

   Example:
   ```java
   @ManyToOne
   private Department department;  // Assumes "department_id" is the foreign key in the database table
   ```

6. **Custom Naming Strategies**:
   - While JPA provides these default conventions, you can customize them using annotations like `@Table`, `@Column`, and `@JoinColumn` to specify the exact database names for tables, columns, and relationships. You can also implement custom naming strategies if needed.

   Example (Custom Column Name):
   ```java
   @Column(name = "full_name")
   private String fullName;  // Maps to column "full_name" in the database table
   ```

   Example (Custom Table Name):
   ```java
   @Entity
   @Table(name = "employees")
   public class Employee {
       // ...
   }
   ```

JPA's naming conventions are designed to simplify the mapping of entities to database tables and columns, but they can be adapted to match your database schema and coding style. Customizing naming conventions is useful when your database schema does not follow the conventions or when you want to maintain specific naming standards in your application.

## 10. Try to use JPA advanced methods in your class project. In the repository layer, you need to use the naming convention to use the method provided by JPA.


## 11. (Optional) Check out a new branch(https://github.com/TAIsRich/springboot-redbook/tree/hw02_01_jdbcTemplate) from branch 02_post_RUD, replace the dao layer using JdbcTemplate.


## 12. (Optional) use JDBC to read the data from database.


## 13. type the code, you need to checkout new branch from branch 02_post_RUD, name the new branch with https://github.com/TAIsRich/springboot-redbook/tree/hw05_01_slides_JPQL.


## 14. What is JPQL?

**JPQL (Java Persistence Query Language)** is a query language defined by the Java Persistence API (JPA) for querying and manipulating data in a database using Java objects and entities. JPQL is a database-agnostic query language, and it is designed to work with any JPA-compliant persistence provider, such as Hibernate, EclipseLink, or OpenJPA.

Here are some key points about JPQL:

1. **Database Agnostic**: JPQL is designed to be database-agnostic, which means that you can write queries in JPQL without concern for the specific SQL dialect of the underlying database. The JPA provider handles the translation of JPQL queries into the appropriate SQL statements for the target database.

2. **Entity-Centric**: JPQL queries operate on JPA entities and their attributes. You write queries using the names of Java classes and fields instead of database table and column names.

3. **Object-Oriented Query Language**: JPQL is object-oriented in nature, which means you can express queries in a way that closely resembles how you work with Java objects and their relationships.

4. **Syntax**: JPQL queries are written as strings, typically using a SQL-like syntax. You use keywords like `SELECT`, `FROM`, `WHERE`, `JOIN`, and others to construct queries. For example:
   ```sql
   SELECT e FROM Employee e WHERE e.department.name = 'HR'
   ```

5. **Parameterized Queries**: JPQL supports parameterized queries, allowing you to define query parameters and bind values to them. This helps prevent SQL injection and makes queries more dynamic and reusable.

6. **Named Queries**: You can define named queries in entity classes using annotations. This is a way to associate a query with a specific entity, making it easy to reuse the query in different parts of your application.

7. **Supports Complex Queries**: JPQL is capable of handling complex queries, including joins, subqueries, aggregates, and more. You can express sophisticated queries to retrieve, filter, and aggregate data.

8. **Type-Safe**: JPQL is type-safe, which means that the JPA provider performs type checking at the time of query creation, helping to catch errors early in the development process.

JPQL is a powerful tool for querying and manipulating data stored in a relational database using JPA entities. It's particularly useful in the context of Java EE applications and ORM (Object-Relational Mapping) frameworks. Developers can use JPQL to express their queries in a natural, object-oriented way, and the JPA provider takes care of translating those queries into SQL statements that are compatible with the underlying database.


## 15. What is @NamedQuery and @NamedQueries?

`@NamedQuery` and `@NamedQueries` are JPA (Java Persistence API) annotations used to define and manage named queries for entities. Named queries allow you to define and name a query in your JPA entity class, making it reusable and more maintainable. You can then use these named queries in your code to retrieve data from the database. Here's an explanation of these annotations:

1. **@NamedQuery**:
   - The `@NamedQuery` annotation is used to define a single named query for an entity class. This named query can be used to retrieve data based on a specific criteria from the database.
   - `@NamedQuery` is typically placed on the entity class itself to associate the query with that class. The named query is specified using the `name` attribute, and the JPQL query string is defined using the `query` attribute.

   Example:
   ```java
   @Entity
   @NamedQuery(name = "findEmployeesByDepartment", query = "SELECT e FROM Employee e WHERE e.department.name = :deptName")
   public class Employee {
       // Entity attributes, constructors, and methods
   }
   ```

   In this example, a named query named "findEmployeesByDepartment" is defined for the `Employee` entity. The query retrieves employees based on the department name.

2. **@NamedQueries**:
   - The `@NamedQueries` annotation is used to define multiple named queries within an entity class. This is useful when you want to define multiple queries associated with the same entity class.
   - `@NamedQueries` is typically placed on the entity class and contains an array of `@NamedQuery` annotations, each defining a named query with a unique name.

   Example:
   ```java
   @Entity
   @NamedQueries({
       @NamedQuery(name = "findEmployeesByDepartment", query = "SELECT e FROM Employee e WHERE e.department.name = :deptName"),
       @NamedQuery(name = "findEmployeesBySalary", query = "SELECT e FROM Employee e WHERE e.salary >= :minSalary")
   })
   public class Employee {
       // Entity attributes, constructors, and methods
   }
   ```

   In this example, two named queries, "findEmployeesByDepartment" and "findEmployeesBySalary," are defined for the `Employee` entity.

Once you've defined named queries using `@NamedQuery` or `@NamedQueries`, you can use them in your code to retrieve data from the database. Here's an example of how to use a named query:

```java
TypedQuery<Employee> query = entityManager.createNamedQuery("findEmployeesByDepartment", Employee.class);
query.setParameter("deptName", "HR");
List<Employee> employees = query.getResultList();
```

Named queries help improve code readability and maintainability, as you don't need to repeat complex JPQL queries in multiple places in your code. Instead, you can reuse and manage them directly in your entity classes.

## 16. What is @Query? In which Interface we write the sql or JPQL?

`@Query` is an annotation used in Spring Data JPA to define custom SQL or JPQL (Java Persistence Query Language) queries for your JPA repository methods. It allows you to specify the query directly in your repository interface, making it easier to create custom queries that go beyond the standard CRUD (Create, Read, Update, Delete) operations.

Here's how `@Query` works and where it's typically used:

1. **In a Repository Interface**: You typically use the `@Query` annotation within a Spring Data JPA repository interface, which extends the `JpaRepository` or `CrudRepository`. This allows you to define custom query methods.

2. **Query Language Selection**: You can write queries in SQL or JPQL, depending on your preference and requirements. By default, JPQL queries are used, but you can specify native SQL queries by setting the `nativeQuery` attribute to `true`.

Here's an example of using `@Query` in a Spring Data JPA repository interface:

```java
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;

public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    // Using JPQL query
    @Query("SELECT e FROM Employee e WHERE e.department.name = :deptName")
    List<Employee> findEmployeesByDepartment(@Param("deptName") String deptName);

    // Using native SQL query
    @Query(value = "SELECT * FROM employees WHERE salary >= :minSalary", nativeQuery = true)
    List<Employee> findEmployeesWithMinSalary(@Param("minSalary") BigDecimal minSalary);
}
```

In this example, two custom query methods are defined using the `@Query` annotation. The first method uses JPQL to retrieve employees based on their department's name, while the second method uses native SQL to find employees with a minimum salary.

The `@Query` annotation allows you to write complex and custom queries that may not be achievable using Spring Data JPA's method naming conventions. You can use named parameters (e.g., `:deptName` and `:minSalary`) to pass parameters into the queries and annotate those parameters with `@Param`.

Custom queries are particularly useful when you need to fetch data that doesn't fit the standard CRUD operations or when you want to optimize a query to retrieve specific data from your database.

## 17.  What is HQL and Criteria Queries?

**HQL (Hibernate Query Language)** and **Criteria Queries** are two approaches to querying a relational database using Hibernate, a popular Java-based Object-Relational Mapping (ORM) framework. They provide alternatives to standard SQL queries when working with Hibernate.

**HQL (Hibernate Query Language)**:

HQL is a powerful, object-oriented query language provided by Hibernate. It is similar to SQL but uses object-oriented concepts, such as classes and properties, instead of database tables and columns. HQL queries are defined using a familiar syntax, making it easier for developers to work with. Key features of HQL include:

- Object-Oriented: HQL is object-oriented and allows you to work with entity classes and their properties, similar to the way you interact with Java objects.
- Database-Agnostic: HQL queries are database-agnostic, and Hibernate translates them into the appropriate SQL dialect for the underlying database.
- Rich Query Capabilities: HQL supports a wide range of query capabilities, including filtering, sorting, joining, and aggregate functions.
- Named Queries: You can define and use named queries with HQL to encapsulate and reuse complex queries.
- Supports Pagination: HQL supports pagination through features like `setMaxResults` and `setFirstResult` methods.

Here's an example of an HQL query in Hibernate:

```java
String hql = "FROM Employee e WHERE e.department.name = :deptName";
Query query = session.createQuery(hql);
query.setParameter("deptName", "HR");
List<Employee> employees = query.list();
```

**Criteria Queries**:

Criteria Queries provide a programmatic and type-safe way to build queries in Hibernate without writing SQL or HQL strings. Criteria Queries are expressed using a set of Java classes and methods, allowing you to create queries using a fluent and type-safe API. Key features of Criteria Queries include:

- Type-Safe: Criteria Queries are type-safe, which means they provide compile-time checks on the query, reducing the risk of runtime errors.
- Fluent API: Criteria Queries use a fluent, method-chaining syntax to build queries, making them easy to read and understand.
- Dynamic Query Building: Criteria Queries are well-suited for dynamic query building scenarios, where the query structure may change based on user inputs or conditions.
- Support for Complex Queries: Criteria Queries can be used to construct complex queries with filtering, sorting, and joining operations.

Here's an example of a Criteria Query in Hibernate:

```java
CriteriaBuilder builder = session.getCriteriaBuilder();
CriteriaQuery<Employee> criteria = builder.createQuery(Employee.class);
Root<Employee> root = criteria.from(Employee.class);

criteria.select(root)
        .where(builder.equal(root.get("department").get("name"), "HR"));

List<Employee> employees = session.createQuery(criteria).getResultList();
```

In summary, both HQL and Criteria Queries are powerful tools in Hibernate for querying databases. The choice between them often depends on developer preference, query complexity, and the need for type safety. Criteria Queries can be a good choice when you want to create dynamic queries or prefer to work with a fluent API. HQL is suitable for writing queries in a SQL-like syntax and may be more familiar to developers accustomed to SQL.

## 18. What is EnityManager?

The `EntityManager` is a core interface in the Java Persistence API (JPA) and is an essential component of the JPA framework. It serves as a bridge between your application and the underlying database, allowing you to perform CRUD (Create, Read, Update, Delete) operations on JPA entities. Here are some key aspects and functions of the `EntityManager`:

1. **Entity Lifecycle Management**:
   - The `EntityManager` is responsible for managing the lifecycle of JPA entities. It can persist new entities, retrieve existing entities, modify entity state, and remove entities from the database.

2. **Transaction Management**:
   - The `EntityManager` operates within a transaction context. You typically start a transaction, perform database operations with the `EntityManager`, and then commit the transaction to persist changes. This ensures data consistency and transactional behavior.

3. **Entity Operations**:
   - The `EntityManager` provides methods for performing operations on JPA entities, such as `persist` (to insert new entities), `find` (to retrieve entities by their primary key), `merge` (to update entity state), and `remove` (to delete entities).

4. **Query Execution**:
   - You can use the `EntityManager` to execute JPQL (Java Persistence Query Language) queries using methods like `createQuery` or `createNamedQuery`. These queries can retrieve specific data from the database.

5. **Caching and Identity Management**:
   - The `EntityManager` manages an entity cache, which helps improve performance by storing recently accessed entities in memory. It also maintains the identity of entities, ensuring that multiple queries for the same entity return the same Java object.

6. **Entity Relationships**:
   - The `EntityManager` handles the navigation of entity relationships, such as `@ManyToOne`, `@OneToMany`, and `@ManyToMany`. You can use it to retrieve related entities and establish relationships between entities.

7. **Persistence Unit Management**:
   - The `EntityManager` is associated with a persistence unit, which defines the database connection and entity mapping. You typically obtain an `EntityManager` through an `EntityManagerFactory`, which is responsible for managing persistence units.

Here's an example of how to create an `EntityManager` and perform basic operations:

```java
EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory("myPersistenceUnit");
EntityManager entityManager = entityManagerFactory.createEntityManager();

// Start a transaction
entityManager.getTransaction().begin();

// Create a new entity and persist it
Employee employee = new Employee();
employee.setName("John Doe");
entityManager.persist(employee);

// Retrieve an entity by its primary key
Employee retrievedEmployee = entityManager.find(Employee.class, 1L);

// Update entity state
retrievedEmployee.setName("Updated Name");

// Commit the transaction to persist changes
entityManager.getTransaction().commit();

// Close the EntityManager
entityManager.close();

// Close the EntityManagerFactory when done
entityManagerFactory.close();
```

The `EntityManager` is a critical component for working with JPA entities and managing interactions with a relational database in Java applications. It abstracts many of the complexities involved in database operations and offers a clean, object-oriented way to interact with the database.

## 19. What is SessionFactory and Session?

`SessionFactory` and `Session` are core components of Hibernate, a popular Java-based Object-Relational Mapping (ORM) framework. They play a central role in managing database connections, transactions, and interactions with the database. Here's an explanation of `SessionFactory` and `Session`:

1. **SessionFactory**:

   - The `SessionFactory` is a factory for creating `Session` objects in Hibernate. It is a heavyweight object that is typically created once during application initialization and shared throughout the application's lifecycle.
   - The `SessionFactory` is responsible for configuring and managing Hibernate settings, including database connection information, entity mappings, and caching options.
   - It serves as a factory for `Session` instances, creating and providing `Session` objects when needed.
   - It is thread-safe, and a single `SessionFactory` instance is used by multiple application threads to create and manage `Session` objects.
   - The `SessionFactory` is typically set up during application initialization and can be stored in a configuration file or created programmatically.

   Example of creating a `SessionFactory`:

   ```java
   Configuration configuration = new Configuration();
   configuration.configure("hibernate.cfg.xml"); // Load configuration from XML file
   SessionFactory sessionFactory = configuration.buildSessionFactory();
   ```

2. **Session**:

   - The `Session` is a lightweight, short-lived object in Hibernate that represents a single unit of work or database transaction.
   - Each database interaction in Hibernate is performed within the context of a `Session`. You typically create and use a `Session` for a specific operation and then close it when the operation is complete.
   - The `Session` provides methods for CRUD operations (Create, Read, Update, Delete), query execution, and transaction management.
   - The `Session` maintains a first-level cache (also known as the persistence context), which stores entities retrieved or created during the current session. This cache helps improve performance and ensures that entities are unique within a session.
   - A `Session` is not thread-safe and should be used in a single-threaded context or managed carefully in a multi-threaded environment.

   Example of creating and using a `Session`:

   ```java
   Session session = sessionFactory.openSession(); // Create a new session
   Transaction transaction = session.beginTransaction(); // Start a transaction

   // Perform database operations
   Employee employee = new Employee();
   employee.setName("John Doe");
   session.save(employee);

   // Commit the transaction
   transaction.commit();

   // Close the session when done
   session.close();
   ```

In summary, the `SessionFactory` is a long-lived factory for creating `Session` instances, while the `Session` is a short-lived object used for managing database interactions within a specific unit of work or transaction. The `SessionFactory` is typically created once and shared across the application, while `Session` objects are created and used as needed for specific database operations. This architecture allows Hibernate to manage database connections efficiently and provide a clean and efficient way to interact with a relational database.


## 20. What is Transaction? how to manage your transaction?

A **transaction** is a fundamental concept in database management that represents a sequence of one or more database operations that should be executed as a single, indivisible unit of work. Transactions are used to ensure data consistency and integrity by providing the following properties, often referred to as ACID properties:

- **Atomicity**: A transaction is atomic, meaning that all the operations within the transaction are executed as a whole, or none of them are. If any operation within the transaction fails, the entire transaction is rolled back, and the database remains in a consistent state.

- **Consistency**: A transaction brings the database from one consistent state to another. It ensures that the database obeys all integrity constraints, such as foreign key relationships and unique constraints.

- **Isolation**: Transactions are typically executed in isolation from each other. This means that the operations within one transaction are not visible to other transactions until the first transaction is completed (committed).

- **Durability**: Once a transaction is committed, the changes it made to the database are permanent and will survive system failures.

In Java applications, you can manage transactions when interacting with a database using various APIs and frameworks, depending on the technology stack you're using. Here are some common ways to manage transactions in Java:

1. **Java Database Connectivity (JDBC)**:
   - When working with raw JDBC, you can manually manage transactions using the `Connection` object. You can start a transaction using `connection.setAutoCommit(false)`, perform database operations, and then commit the transaction using `connection.commit()`. If an exception occurs, you can roll back the transaction using `connection.rollback()`.

   Example:
   ```java
   Connection connection = dataSource.getConnection();
   connection.setAutoCommit(false); // Start a transaction

   // Perform database operations

   connection.commit(); // Commit the transaction
   // or
   connection.rollback(); // Roll back the transaction in case of an exception
   ```

2. **Spring Framework**:
   - Spring provides a comprehensive framework for managing transactions in Java applications. You can use Spring's declarative transaction management, where you annotate methods or classes with `@Transactional`. Spring takes care of transaction demarcation, propagation, and error handling. You can configure transaction management using XML or Java configuration.

   Example:
   ```java
   @Service
   @Transactional
   public class EmployeeService {
       @Autowired
       private EmployeeRepository employeeRepository;

       public void updateEmployee(Employee employee) {
           // Perform database operations
           employeeRepository.save(employee);
       }
   }
   ```

3. **Java Persistence API (JPA)**:
   - When using JPA with a JPA provider like Hibernate or EclipseLink, you can use the `EntityManager` to manage transactions. You typically begin a transaction with `entityManager.getTransaction().begin()`, perform database operations, and then either commit or roll back the transaction using `entityManager.getTransaction().commit()` or `entityManager.getTransaction().rollback()`.

   Example:
   ```java
   EntityManager entityManager = entityManagerFactory.createEntityManager();
   EntityTransaction transaction = entityManager.getTransaction();
   transaction.begin(); // Start a transaction

   // Perform database operations

   transaction.commit(); // Commit the transaction
   // or
   transaction.rollback(); // Roll back the transaction in case of an exception
   ```

4. **Java EE (Enterprise Edition)**:
   - In a Java EE environment, you can manage transactions using container-managed transactions (CMT) or bean-managed transactions (BMT). The container takes care of transaction management in CMT, while you have more control in BMT.

   Example (CMT):
   ```java
   @Stateless
   public class EmployeeService {
       @PersistenceContext
       private EntityManager entityManager;

       public void updateEmployee(Employee employee) {
           // Perform database operations
           entityManager.persist(employee);
       }
   }
   ```

Transaction management is a critical aspect of database operations, and the choice of how to manage transactions depends on your application's requirements and the technology stack you are using. Frameworks like Spring and JPA provide abstractions and tools to simplify transaction management, making it more developer-friendly and less error-prone.


## 21. What is hibernate Caching?

**Hibernate caching** is a mechanism used in the Hibernate ORM (Object-Relational Mapping) framework to improve the performance and reduce the load on a relational database by storing frequently accessed data in memory. Caching helps minimize the number of database queries and can significantly improve the response time of applications. Hibernate provides several types of caching, including the following:

1. **First-Level Cache (Session Cache)**:
   - The first-level cache, also known as the session cache, is specific to a Hibernate `Session` or `EntityManager`. It is a temporary cache that stores entities (Java objects) loaded or saved within the current session.
   - When an entity is loaded using `get()`, `load()`, or a query within a session, it is stored in the first-level cache. Subsequent requests for the same entity within the session are served from the cache, reducing the need for database queries.

2. **Second-Level Cache**:
   - The second-level cache is shared among multiple sessions and provides a broader scope of caching. It is used to store data that is frequently accessed and shared across sessions.
   - Hibernate supports various second-level cache providers, such as Ehcache, Infinispan, and Hazelcast. These caches can be configured at the entity or collection level.
   - Entities, queries, and collections can be configured to use the second-level cache, making it possible for multiple sessions to benefit from cached data.

3. **Query Cache**:
   - The query cache is used to cache the results of queries, which can be beneficial when the same query is executed frequently. It reduces the need to re-execute the query against the database.
   - When a query is executed with the query cache enabled, the results are stored in the cache, allowing subsequent executions of the same query to return cached results.

Benefits of Hibernate Caching:

- **Improved Performance**: Caching reduces the number of database queries, resulting in faster application response times.
- **Reduced Database Load**: By serving data from the cache, the load on the database server is reduced, which can lead to better database performance.
- **Optimized Scalability**: Caching is particularly useful in scenarios with high user loads and read-heavy workloads.

Challenges and Considerations:

- **Cache Consistency**: Caching introduces the challenge of maintaining data consistency between the cache and the database. Hibernate provides mechanisms for cache eviction and synchronization.
- **Cache Configuration**: Configuring and fine-tuning the cache settings can be complex, and it requires a good understanding of the application's data access patterns.
- **Managing Stale Data**: Caching can lead to stale data if changes are made to the database outside the scope of Hibernate (e.g., via direct SQL updates).

Overall, Hibernate caching is a valuable feature that can significantly enhance the performance and scalability of applications using Hibernate. However, it should be used with care, considering the specific needs of the application and database. Proper cache configuration, management, and monitoring are essential to reap the benefits of caching without introducing data inconsistencies.

## 22. What is the difference between first-level cache and second-level cache?

**First-level cache** and **second-level cache** are two caching mechanisms in the Hibernate ORM (Object-Relational Mapping) framework that help improve the performance of database operations by reducing the need for repeated database queries. Here are the key differences between these two types of caching:

**First-Level Cache (Session Cache):**

1. **Scope**:
   - The first-level cache is specific to a single Hibernate `Session` (or JPA `EntityManager`). Each session has its own isolated first-level cache.
   - Entities loaded within a session are stored in the first-level cache and are not visible to other sessions.

2. **Lifetime**:
   - The first-level cache has a limited lifetime and exists only for the duration of the session. When the session is closed, the first-level cache is also destroyed, and cached entities are evicted.

3. **Granularity**:
   - The first-level cache operates at the entity level. It caches individual entities, and changes made to an entity within a session are reflected in the cache.

4. **Isolation**:
   - The first-level cache is isolated from other sessions. Entities loaded in one session are not visible to or shareable with other sessions. Changes made in one session do not affect other sessions.

**Second-Level Cache:**

1. **Scope**:
   - The second-level cache is shared among multiple Hibernate sessions (or JPA entity managers). It provides a broader scope of caching, and data stored in the second-level cache can be accessed by different sessions.

2. **Lifetime**:
   - The second-level cache has a longer lifetime and can persist beyond the lifespan of individual sessions. It can store data that can be reused by multiple sessions over time.

3. **Granularity**:
   - The second-level cache can be configured at various levels, including entity caching, query caching, and collection caching. This allows for fine-grained control over which data is cached.

4. **Isolation**:
   - The second-level cache allows sharing of cached data among sessions, enabling multiple sessions to access and utilize cached data. Changes made by one session can affect other sessions, depending on cache settings.

**Use Cases**:

- **First-Level Cache**:
  - The first-level cache is used for caching entities within the current session.
  - It is suitable for optimizing repeated accesses to the same entities within a single session.

- **Second-Level Cache**:
  - The second-level cache is used for caching data that is shared and accessed by multiple sessions.
  - It is beneficial when multiple sessions need to access the same data without redundant database queries.

In summary, the key distinction between the first-level cache and the second-level cache in Hibernate is their scope and lifespan. The first-level cache is session-specific, isolated, and short-lived, while the second-level cache is shared, longer-lived, and provides caching on a broader scale. Hibernate allows developers to configure and use both types of caching to optimize database access based on specific application requirements.

## 23. How do you understand @Transactional? (不要clone，要自己抄写并测试transactional，https://github.com/TAIsRich/tutorial-transaction)
`@Transactional`: 配置方法的事务行为，保持原子性

```java
/*
Let's assume you have a Spring application with a service class that performs database operations. You want to use Spring's transaction management annotations to ensure that these operations are executed within a transaction.

In this example:

The @Service annotation marks the UserService class as a Spring service component.
The @Transactional annotation is applied to the createUser method. This annotation indicates that the method should be executed within a transaction. If the method completes without errors, the transaction is committed, and changes are persisted to the database. If an exception is thrown, the transaction is rolled back, ensuring data consistency.
The UserRepository is assumed to be a Spring Data JPA repository or a similar data access component for managing user data.
By using @Transactional, you delegate the management of transactions to Spring, which will automatically begin, commit, or roll back transactions based on the method's execution. This ensures that the createUser method either saves the user and commits the transaction or rolls back the transaction if any errors occur during the process.
*/

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    @Transactional
    public User createUser(String username, String email) {
        User user = new User(username, email);
        return userRepository.save(user);
    }
}
```

## 24. Write a simple factory design pattern.
a Shape interface and three concrete classes implementing it: Circle, Rectangle, and Triangle. And also create a ShapeFactory that can create instances of these shapes based on the shape's name.

```java
// Shape.java (Interface)
public interface Shape {
    void draw();
}

// Circle.java (Concrete class)
public class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Circle");
    }
}

// Rectangle.java (Concrete class)
public class Rectangle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Rectangle");
    }
}

// Triangle.java (Concrete class)
public class Triangle implements Shape {
    @Override
    public void draw() {
        System.out.println("Drawing a Triangle");
    }
}

// ShapeFactory.java (Factory class)
public class ShapeFactory {
    public Shape createShape(String shapeType) {
        if (shapeType == null) {
            return null;
        }
        if (shapeType.equalsIgnoreCase("CIRCLE")) {
            return new Circle();
        } else if (shapeType.equalsIgnoreCase("RECTANGLE")) {
            return new Rectangle();
        } else if (shapeType.equalsIgnoreCase("TRIANGLE")) {
            return new Triangle();
        }
        return null;
    }
}

// Main.java (Usage)
public class Main {
    public static void main(String[] args) {
        ShapeFactory shapeFactory = new ShapeFactory();

        Shape circle = shapeFactory.createShape("CIRCLE");
        circle.draw();

        Shape rectangle = shapeFactory.createShape("RECTANGLE");
        rectangle.draw();

        Shape triangle = shapeFactory.createShape("TRIANGLE");
        triangle.draw();
    }
}
```
 
