1. Practice collection<br>


2. What is the checked exception and unchecked exception in Java, could you give one example?<br>
In Java, exceptions are categorized into two main types: checked exceptions and unchecked exceptions. checked exceptions must be explicitly handled or declared, while unchecked exceptions do not require explicit handling and can propagate up the call stack until they are caught or cause the program to terminate. It's important to choose the appropriate exception type based on the nature of the error and whether it can be reasonably anticipated and handled in your code. Checked Exceptions: IOException. Unchecked Exceptions (RuntimeExceptions): NullPointerException<br>


3. Can there be multiple finally blocks?<br>
In Java, multiple finally blocks associated with a single try block. These finally blocks are executed in the order they appear in the code, from top to bottom. Each finally block allows you to specify code that should be executed regardless of whether an exception was thrown or not. This is commonly used for cleanup operations, such as closing resources like files, and database connections, or releasing other resources.<br>


4. When both catch and finally return values, what will be the final result?<br>
When both a catch block and a finally block return values, the value returned by the finally block will override the value returned by the catch block. This means that the value returned by the finally block will be the one that is ultimately returned from the method.<br>


5. What is Runtime/unchecked exception? what is Compile/Checked Exception? <br>
In Java, exceptions are categorized into two main types: checked exceptions and unchecked exceptions.checked exceptions must be explicitly handled or declared, while unchecked exceptions do not require explicit handling and can propagate up the call stack until they are caught or cause the program to terminate. It's important to choose the appropriate exception type based on the nature of the error and whether it can be reasonably anticipated and handled in your code.<br>


6. What is the difference between throw and throws?<br>
throw to raise specific exceptions when certain conditions are met within a method, and you use throws in the method signature to inform callers about the exceptions they might need to handle or propagate.<br>


7. Run the below three pieces codes, Noticed the printed exceptions. why do we put the Null/Runtime exception before Exception ?<br>
   The order of catching exceptions in Java is from light to heavy. The order is RuntimeException, Checked Exceptions, and Error. The advantage of this is that when printing exceptions, you can quickly locate bugs based on the exception information. However, general exceptions often cannot identify specific problems. <br>

```
public class Main {
    public static void main(String[] args) {
        int a = 0;
        int b = 3
        String s = null;
        try {
            System.out.println(b / a);
            System.out.println(s.equals("aa"));
            throw new RuntimeException();
        } catch (ArithmeticException e) {
            e.printStackTrace();
        } catch (NullPointerException e) {
            e.printStackTrace();
        } catch (RuntimeException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.getMessage();
        }
        System.out.println("End ...");
    }
}

public class Main {
    public static void main(String[] args) {
        int a = 0;
        int b = 3;
        String s = null;
        try {
            // System.out.println(b / a);
            System.out.println(s.equals("aa"));
            throw new RuntimeException();
        } catch (ArithmeticException e) {
            e.printStackTrace();
        } catch (NullPointerException e) {
            e.printStackTrace();
        } catch (RuntimeException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.getMessage();
        }
        System.out.println("End ...");
    }
}

public class Main {
    public static void main(String[] args) {
        int a = 0;
        int b = 3;
        String s = null;
        try {
        // System.out.println(b / a);
        // System.out.println(s.equals("aa"));

            throw new RuntimeException();
        } catch (ArithmeticException e) {
            e.printStackTrace();
        } catch (NullPointerException e) {
            e.printStackTrace();
        } catch (RuntimeException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.getMessage();
        }
        System.out.println("End ...");
    }
} 
```

7. What is optional? why do you use it? write an optional example. <br>
Optional is a class introduced in Java 8 (java.util.Optional) that is used to represent an optional value, meaning a value that may or may not be present. It is a container class that helps in dealing with situations where a value might be absent, reducing the need for null checks and improving code clarity. Optional is used to address the problem of null references, which can lead to NullPointerExceptions in Java code. By using Optional, you can make your code more robust and self-explanatory because it explicitly indicates when a value may be absent.<br>

```
        // Creating an Optional with a non-null value
        Optional<String> nameOptional = Optional.of("John");

        // Creating an Optional with a potentially null value
        String nullableName = null;
        Optional<String> nullableNameOptional = Optional.ofNullable(nullableName);

        // Checking if a value is present in the Optional
        if (nameOptional.isPresent()) {
            System.out.println("Name is present: " + nameOptional.get());
        } else {
            System.out.println("Name is absent.");
        }
```

8. Why finally always be executed ?<br>
The finally block in Java is designed to always be executed, regardless of whether an exception is thrown or not. This behavior is an important part of Java's exception-handling mechanism and serves several purposes such as Resource Cleanup, Guaranteed Execution, and Exception Handling. finally is used for critical cleanup operations and is designed to provide a way to ensure that specific code is executed under all circumstances, making Java programs more robust and reliable in the face of exceptions.<br>


9. Practice collection problems here: <br>
https://github.com/TAIsRich/chuwa-eij-tutorial/tree/main/02-java-core/src/main/java/com/chuwa/exercise/collection <br>


10. What is Java 8 new features ?<br>
Java 8 introduced several significant features and enhancements to the Java programming language. Some of the key features introduced in Java 8 include:Lambda Expressions,Functional Interfaces,Stream API,Default and Static Methods in Interfaces,Method References,Functional Interfaces in java.util.function,Date and Time API (java.time),Nashorn JavaScript Engine,New Collectors,Improved Annotations.<br>


11. What are the types of design patterns in Java?<br>
Design patterns in Java, as in any programming language, are reusable solutions to common software design problems. They help promote best practices, improve code organization, and enhance code maintainability. Java, like other object-oriented programming languages, supports a wide range of design patterns. Some of the most commonly used design patterns in Java are categorized into three main categories: Creational Design Patterns: Singleton Pattern: Ensures a class has only one instance and provides a global point of access to it. Factory Method Pattern: Defines an interface for creating an object but lets subclasses alter the type of objects that will be created. Abstract Factory Pattern: Provides an interface for creating families of related or dependent objects without specifying their concrete classes. Builder Pattern: Separates the construction of a complex object from its representation, allowing the same construction process to create different representations. Prototype Pattern: Creates new objects by copying an existing object, known as the prototype. Structural Design Patterns: Adapter Pattern: Allows the interface of an existing class to be used as another interface. Decorator Pattern: Adds new functionality to objects dynamically without altering their structure. Proxy Pattern: Provides a surrogate or placeholder for another object to control access to it. Composite Pattern: Composes objects into tree structures to represent part-whole hierarchies. Bridge Pattern: Separates an object's abstraction from its implementation so that the two can vary independently.Behavioral Design Patterns: Observer Pattern: Defines a one-to-many dependency between objects, so that when one object changes state, all its dependents are notified and updated automatically. Strategy Pattern: Defines a family of algorithms, encapsulates each one and makes them interchangeable. It allows the algorithm to vary independently from clients that use it. Command Pattern: Encapsulates a request as an object, thereby allowing for parameterization of clients with queues, requests, and operations. State Pattern: Allows an object to alter its behavior when its internal state changes. The object will appear to change its class. Chain of Responsibility Pattern: Passes the request along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain. Interpreter Pattern: Defines the grammar for a language and provides an interpreter to interpret sentences in the language.<br>


12. What are the SOLID Principles?<br>
The SOLID principles are a set of five design principles in object-oriented programming that help guide developers in writing clean, maintainable, and extensible code. These principles were introduced by Robert C. Martin and represent a foundation for good software design. The SOLID acronym stands for: Single Responsibility Principle (SRP), Open/Closed Principle (OCP), Liskov Substitution Principle (LSP), Interface Segregation Principle (ISP), and Dependency Inversion Principle (DIP). <br>


13. How can you achieve thread-safe singleton patterns in Java ?<br>
To achieve a thread-safe singleton pattern in Java, we need to ensure that only one instance of the singleton class is created and that it can be safely accessed by multiple threads without causing data corruption or inconsistencies. Here are some common ways to implement a thread-safe singleton pattern in Java such as Eager Initialization (Thread-Safe), Lazy Initialization (Thread-Safe using synchronized method), Lazy Initialization (Thread-Safe using double-check locking), Initialization-on-demand holder idiom (Thread-Safe). <br>


14. What do you understand by the Open-Closed Principle (OCP)? <br>
The Open-Closed Principle (OCP) is one of the five SOLID principles of object-oriented programming and design, introduced by Bertrand Meyer. The OCP states:"Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification."In essence, the Open-Closed Principle encourages developers to design software in a way that allows for the extension of existing functionality without altering the existing code. It promotes a strategy where you can add new features, behaviors, or functionalities to a software system by introducing new code rather than modifying the existing code.<br>


15. Liskov’s substitution principle states that if class B is a subtype of class A, then object of type A may be substituted with any object of type B. What does this actually mean? (from OA ) choose your answer.<br>
It means if a method is present in class A, it should also be present in class B so that the object of type B could substitute object of type A. <br>


16. Watch the design pattern video, and type the code, submit it to MavenProject folder<br>
singleton: https://www.bilibili.com/video/BV1Np4y1z7BU?p=22
Factory: https://www.bilibili.com/video/BV1Np4y1z7BU?p=35&vd_source=310561eab1216a27f7accf859bf7f6d9
Builder: https://www.bilibili.com/video/BV1Np4y1z7BU?p=50&vd_source=310561eab1216a27f7accf859bf7f6d9
Publisher_Subscriber: https://www.bilibili.com/video/BV1Np4y1z7BU?p=114&vd_source=310561eab1216a27f
7accf859bf7f6d9

Coding in the Coding folder. 



